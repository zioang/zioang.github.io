<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Java虚拟机（一）</title>
    <url>/2020/07/13/jvm_1/</url>
    <content><![CDATA[<h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>&emsp;&emsp;本系列笔记主要参考了 “<strong>深入理解Java虚拟机 - JVM高级特性与最佳实践</strong>“、”<strong>实战Java虚拟机 - JVM故障诊断与性能优化(第二版)</strong>“ 和相关博客。因此，若无特别说明jdk的版本，那么所使用的 jdk 版本为 1.7。 </p>
<h3 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h3><p>&emsp;&emsp;Java堆是被所有线程所共享的一块区域( Java虚拟机所管理的内存中最大的一块 )，几乎所有的对象实例都存放在堆中( <strong>由于栈上分配、标量替换优化技术的出现，导致不是那么的绝对</strong> )，且Java堆是完全自动化管理的，通过垃圾回收机制，垃圾对象会被自动清理，而不需要人为释放。<br>&emsp;&emsp;根据垃圾回收机制的不同，Java堆有可能会拥有不同的结构。其中，最为常见的一种是将其分为新生代和老年代。其中，新生代存放新生对象或年龄不大的对象，老年代则存放老年对象。如下表所示，新生代可分为 Eden、S0、S1，其中 S0 和 S1 被称为幸存者区 ( Survivor Space )， 它们分别又被称为 From 和 To 区域，它们是两块大小相等、可以互换的内存空间。</p>
<center>
    <img style="border-radius: 0.3125em; margin-top: 10px; width: 600px; height: 300px; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src="https://blog-1253514421.cos.ap-shanghai.myqcloud.com/20200716093220.png">
    <br>
</center>

<p>&emsp;&emsp;在绝大多数情况下，对象首先是在 Eden 区创建，否则，也就是少数的情况下，其是在 Tenured 区分配。幸存者区域是新生代与老年代的缓冲区域，当触发 Minor GC ( 新生代回收 ) 后将仍然存活的对象从 Eden 区中移动到 S0 中去，这样 Eden 就被清空可以分配给新的对象。而当再一次触发 Minor GC 后，S0 和 Eden 中存活的对象被移动到 S1 中，S0 即被清空。在同一时刻, 只有 Eden 和一个 Survivor Space 同时被操作。所以 S0 与 S1 两块区同时会至少有一个为空闲的。当每次对象从 Eden 复制到 Survivor Space 或者在 Survivor Space 之间复制时，计数器会自动增加其值。默认情况下如果复制发生超过 16 次，JVM 就会停止复制并把他们移到 Tenured 区。<br>&emsp;&emsp;Tenured 区用于存放程序中经过几次垃圾回收后还存活的对象，例如缓存的对象等。当 Tenured 区内存空间不够时，JVM 会在 Tenured 区进行一次 Major GC ( 老年代回收 )，Major GC 的速度一般会比 Minor GC 慢10倍以上。</p>
<h4 id="Java堆溢出"><a href="#Java堆溢出" class="headerlink" title="Java堆溢出"></a>Java堆溢出</h4><p>&emsp;&emsp;Java堆内存的溢出异常是实际应用中最常见的内存溢出异常情况。出现Java堆内存溢出时，异常堆栈信息 <code>java.lang.OutOfMemoryError</code> 会跟着进一步提示 <code>Java heap space</code>。这里，我们首先限制Java堆的大小为20M，避免堆的自动扩展。然后通过不断创建对象，来模拟在对象数量达到最大堆的容量限制后，产生内存溢出异常，代码见下。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Java堆溢出测试</span></span><br><span class="line"><span class="comment"> * VM Args: -Xms20m -Xmx20m</span></span><br><span class="line"><span class="comment"> * -Xms: 堆的最小值</span></span><br><span class="line"><span class="comment"> * -Xmx: 堆的最大值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapOOM</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">OOMObject</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        List&lt;OOMObject&gt; list = <span class="keyword">new</span> ArrayList&lt;OOMObject&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> OOMObject());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>&emsp;&emsp;使用 <strong>-Xms20m -Xmx20m</strong> 执行以上代码后，部分结果如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Exception in thread <span class="string">"main"</span> java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">	at java.util.Arrays.copyOf(Arrays.java:<span class="number">3210</span>)</span><br><span class="line">	at java.util.Arrays.copyOf(Arrays.java:<span class="number">3181</span>)</span><br></pre></td></tr></table></figure></p>
<h3 id="Java栈"><a href="#Java栈" class="headerlink" title="Java栈"></a>Java栈</h3><p>&emsp;&emsp;Java栈( Java Stacks, 又称 Java 虚拟机栈, Java Virtual Machine Stacks )是一块<strong>线程私有的内存空间</strong>，其和线程执行密切相关。线程执行的基本行为是方法调用，而每次方法调用的数据都是通过Java栈来传递的。每个方法被执行的时候，都会同时创建一个 <strong>栈帧(Stack Frame, Java栈的基本单位)</strong> 用于存储局部变量表、操作数栈、帧数据区(包含动态联接、方法出口、异常处理表等数据)等信息。因此，每一个方法被调用直至执行完成的过程，就对应着一个栈帧在Java栈中从入栈到出栈的过程。</p>
<p>&emsp;&emsp;栈帧在Java栈中的出入栈过程，与数据结构中的栈操作过程类似，如下图。每一次方法的<strong>调用</strong>，都会有一个对应的栈帧被<strong>压入</strong>Java栈。当没到该方法<strong>调用结束</strong>时，栈帧继续在栈中等待，直到轮到该方法返回时，栈帧从Java栈中被<strong>弹出</strong>。Java方法有两站返回方法的方式，一种是正常的方法返回，即return指令；另外一种则是异常抛出。而不管是哪一种方式，都会导致栈帧被弹出。</p>
<center>
    <img style="border-radius: 0.3125em; margin-top: 10px; width: 700px; height: 400px; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src="https://blog-1253514421.cos.ap-shanghai.myqcloud.com/20200714170138.png">
    <br>
</center>

<h4 id="Java栈溢出"><a href="#Java栈溢出" class="headerlink" title="Java栈溢出"></a>Java栈溢出</h4><p>&emsp;&emsp;如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出 <strong>StackOverflowError</strong> 异常。为此，Java虚拟机提供了参数 <strong>-Xss</strong> 来指定线程的最大空间，这个参数也直接决定了方法调用的 <strong>最大深度</strong>。于是，我们可以通过该参数来模拟下Java栈溢出。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackSOF</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> stackLength = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stackLeak</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ++stackLength;</span><br><span class="line">        stackLeak();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable</span>&#123;</span><br><span class="line"></span><br><span class="line">        StackSOF ssof = <span class="keyword">new</span> StackSOF();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ssof.stackLeak();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Throwable e)&#123;</span><br><span class="line">            System.out.println(<span class="string">"stack length: "</span> + ssof.stackLength);</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>&emsp;&emsp;由于该代码中未给出递归方法的出口，因此当递归达到了允许调用的最大深度后，程序将抛出错误，并打印最大的调用深度。<br>&emsp;&emsp;使用 <strong>-Xss160k</strong> 执行以上代码后，部分结果如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">stack length: <span class="number">776</span></span><br><span class="line">Exception in thread <span class="string">"main"</span> java.lang.StackOverflowError</span><br><span class="line">	at oom.StackSOF.stackLeak(StackSOF.java:<span class="number">13</span>)</span><br><span class="line">	at oom.StackSOF.stackLeak(StackSOF.java:<span class="number">14</span>)</span><br></pre></td></tr></table></figure><br>&emsp;&emsp;而使用 <strong>-Xss320k</strong> 执行以上代码后，部分结果如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">stack length: <span class="number">2638</span></span><br><span class="line">Exception in thread <span class="string">"main"</span> java.lang.StackOverflowError</span><br><span class="line">	at oom.StackSOF.stackLeak(StackSOF.java:<span class="number">13</span>)</span><br></pre></td></tr></table></figure><br>&emsp;&emsp;可以看到，随着 -Xss 值的增大，方法可以获得更深的调用层次。因此，我们可以得到一个信息：方法嵌套调用的层次很大程度上由栈的大小决定，即栈越大，方法可嵌套调用的次数就越多。 </p>
<h4 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h4><p>&emsp;&emsp;局部变量表的最小单位称为 <strong>“变量槽(Slot)”</strong>。它可用来保存方法的参数和局部变量，并且所需要的内存空间在编译期间完成分配，因此在方法运行期间是不会改变局部变量表的大小的。其可以是下表中的任意类型。<br>|   数据类型    | 占用的Slot个数 |<br>| :—————-: | :——————: |<br>|    boolean    |       1        |<br>|     byte      |       1        |<br>|     char      |       1        |<br>|     short     |       1        |<br>|      int      |       1        |<br>|     float     |       1        |<br>|     long      |       2        |<br>|    double     |       2        |<br>|   reference   |     1 or 2     |<br>| returnAddress |       1        |<br>&emsp;&emsp;表中，long 和 double 类型都是 64 位数据类型，需占用 2 个连续的 Slot。 reference 类型 不等同于对象本身，它可能是一个指向对象起始地址的引用指针，也可能指向一个代表对象的句柄或者其他与此对象相关的位置，因此它会占用 1 或 2 个 Slot。而 returnAddress 类型指向了一条字节码指令的地址。<br>&emsp;&emsp;由于局部变量表存储在栈帧中，因此，如果方法所拥有的 <strong>参数和局部变量</strong> 较多，会使局部变量表 <strong>膨胀</strong>，从而每一次方法调用就会 <strong>占用更多的栈空间</strong>，最终导致方法的嵌套调用次数 <strong>减少</strong>。下面的代码将展示在含参数和局部变量，及不含参数的情况下对方法调用层次的影响。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * VM Args: -Xss160K</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackDeep</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> stackLength = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">recursion</span><span class="params">(<span class="keyword">long</span> a, <span class="keyword">long</span> b, <span class="keyword">long</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> d = <span class="number">4</span>, e = <span class="number">5</span>, f = <span class="number">6</span>;</span><br><span class="line">        ++stackLength;</span><br><span class="line">        recursion(a, b, c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">recursion</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ++stackLength;</span><br><span class="line">        recursion();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            recursion(<span class="number">1L</span>, <span class="number">2L</span>, <span class="number">3L</span>);</span><br><span class="line">            <span class="comment">// recursion();</span></span><br><span class="line">        &#125;<span class="keyword">catch</span> (Throwable e)&#123;</span><br><span class="line">            System.out.println(<span class="string">"stack length: "</span> + stackLength);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>&emsp;&emsp;如上代码所示，当我们调用含参数及局部变量的方法时，它所能调用的层次如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">stack length: <span class="number">388</span></span><br><span class="line">java.lang.StackOverflowError</span><br><span class="line">	at oom.StackDeep.recursion(StackDeep.java:<span class="number">12</span>)</span><br><span class="line">	at oom.StackDeep.recursion(StackDeep.java:<span class="number">14</span>)</span><br></pre></td></tr></table></figure><br>&emsp;&emsp;而当我们调用不含参数及局部变量的方法时，它所能调用的层次如下表所示。通过对比两者的差异，可以看到，在相同栈容量下，局部变量或参数少的方法，可以达到更深层次的方法调用。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">stack length: <span class="number">854</span></span><br><span class="line">java.lang.StackOverflowError</span><br><span class="line">	at oom.StackDeep.recursion(StackDeep.java:<span class="number">18</span>)</span><br><span class="line">	at oom.StackDeep.recursion(StackDeep.java:<span class="number">19</span>)</span><br></pre></td></tr></table></figure><br>&emsp;&emsp;为了尽可能节省栈帧的空间，局部变量表实现了 <strong>Slot 复用</strong> 的功能(如下代码所示，通过 <strong>-XX:+PrintGC</strong> 来查看垃圾回收前后堆的大小)。由于方法中定义的变量，其作用域并不一定会覆盖整个方法。如果当前的字节码 PC 计数器的值已经超出了某个变量的作用域，那么这个变量所对应的 Slot 就可以被其他变量所使用，而与此会影响系统垃圾回收的行为。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 变量槽复用</span></span><br><span class="line"><span class="comment"> * VM Args: -XX:+PrintGC</span></span><br><span class="line"><span class="comment"> * PrintGC: 打印GC信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LocalVarGC</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">localVarGC1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] a = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">6</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">localVarGC2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] a = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">6</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">localVarGC3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] a = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">6</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        LocalVarGC gc = <span class="keyword">new</span> LocalVarGC();</span><br><span class="line">        gc.localVarGC1();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>&emsp;&emsp;在 localVarGC1() 中，在申请空间后，立即进行垃圾回收，由于 byte 数组被变量 a 引用，因此无法回收这块空间，GC 打印如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[Full GC <span class="number">6592</span>K-&gt;<span class="number">6431</span>K(<span class="number">125952</span>K), <span class="number">0.0095330</span> secs]</span><br></pre></td></tr></table></figure><br>&emsp;&emsp;在 localVarGC2() 中，虽然 a 在垃圾回收前就被失效了，但是变量 a 在局部变量表中依然存在，即变量 a 与 byte 数组之间仍存在关联，因此无法回收这块空间，GC 打印如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[Full GC <span class="number">6560</span>K-&gt;<span class="number">6431</span>K(<span class="number">125952</span>K), <span class="number">0.0072220</span> secs]</span><br></pre></td></tr></table></figure><br>&emsp;&emsp;在 localVarGC3() 中，在垃圾回收前，先使变量 a 失效，然后声明了一个变量 b，这样便使变量 b 复用了变量 a 的 Slot，即复用打断了变量 a 与 byte 数组之间的关联，因此垃圾回收器顺利回收了 byte 数组。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[Full GC <span class="number">7475</span>K-&gt;<span class="number">440</span>K(<span class="number">125952</span>K), <span class="number">0.0075550</span> secs]</span><br></pre></td></tr></table></figure><br>&emsp;&emsp;从 localVarGC3() 的打印信息中可以看到，堆空间从 7475K 变回 440K，释放了约 6MB 空间，进而可以推断出 byte 数组被回收释放。</p>
<h4 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h4><p>&emsp;&emsp;每一个独立的栈帧中，除了包含局部变量表外，还包括操作数栈，它主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间。如下代码，完成了变量 a 与变量 b 相加后加值赋予给变量 c 的功能。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleOperandStack</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">10</span>, b = <span class="number">20</span>;</span><br><span class="line">        <span class="keyword">int</span> c = a + b;</span><br><span class="line">        System.out.println(c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>&emsp;&emsp;编译上述代码后，通过 <strong>javap</strong> 指令来执行对应文件，可得到下表中的信息。<br><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">4</span>, args_size=<span class="number">1</span></span><br><span class="line">         // 将 <span class="number">10</span> 压入操作数栈</span><br><span class="line">         <span class="number">0</span>: bipush        <span class="number">10</span></span><br><span class="line">         // 将操作数栈中的值出栈并保存到局部变量表中的第 <span class="number">1</span> 个 Slot 位置</span><br><span class="line">         <span class="number">2</span>: istore_1</span><br><span class="line">         // 将 <span class="number">20</span> 压入操作数栈</span><br><span class="line">         <span class="number">3</span>: bipush        <span class="number">20</span></span><br><span class="line">         // 将操作数栈中的值出栈并保存到局部变量表中的第 <span class="number">2</span> 个 Slot 位置</span><br><span class="line">         <span class="number">5</span>: istore_2</span><br><span class="line">         // 复制局部变量表中第 <span class="number">1</span> 个 Slot 位置的值，并压入到操作数栈</span><br><span class="line">         <span class="number">6</span>: iload_1</span><br><span class="line">         // 同上</span><br><span class="line">         <span class="number">7</span>: iload_2</span><br><span class="line">         // iadd 的指令是用来将两个栈顶的值依次出栈，</span><br><span class="line">         // 对两个值做整形加法，将结果重新入栈</span><br><span class="line">         <span class="number">8</span>: iadd</span><br><span class="line">         // 将操作数栈中的值出栈并保存到局部变量表中的第 <span class="number">3</span> 个 Slot 位置</span><br><span class="line">         <span class="number">9</span>: istore_3</span><br><span class="line">        // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">        // 调用输出方法</span><br><span class="line">        <span class="number">10</span>: getstatic     #<span class="number">2</span></span><br><span class="line">        // 复制局部变量表中第 <span class="number">3</span> 个 Slot 位置的值，并压入到操作数栈              </span><br><span class="line">        <span class="number">13</span>: iload_3</span><br><span class="line">        // Method java/io/PrintStream.println:(I)V</span><br><span class="line">        //打印操作数栈的栈顶的值</span><br><span class="line">        <span class="number">14</span>: invokevirtual #<span class="number">3</span>                 </span><br><span class="line">        <span class="number">17</span>: <span class="keyword">return</span></span><br><span class="line">      // 局部变量表</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0      18     0  args   [Ljava/lang/String;</span><br><span class="line">            <span class="number">3</span>      <span class="number">15</span>     <span class="number">1</span>     <span class="keyword">a</span>   I</span><br><span class="line">            <span class="number">6</span>      <span class="number">12</span>     <span class="number">2</span>     <span class="keyword">b</span>   I</span><br><span class="line">           <span class="number">10</span>       <span class="number">8</span>     <span class="number">3</span>     <span class="keyword">c</span>   I</span><br></pre></td></tr></table></figure><br>&emsp;&emsp;由上表内容可知，操作数栈的深度为 2，局部变量表的空间为 4。具体的流程，已在上述代码中添加了相应的注释，如需更深入的了解，可以参考这篇 <a href="https://zhuanlan.zhihu.com/p/45354152" target="_blank" rel="noopener">博客</a>。下图中，也稍微描述了下代码执行过程中，操作数栈中的变化和局部变量表中的值。</p>
<center>
    <img style="border-radius: 0.3125em; margin-top: 10px; width: 600px; height: 400px; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src="https://blog-1253514421.cos.ap-shanghai.myqcloud.com/20200715155836.png">
    <br>
</center>

<h4 id="帧数据区"><a href="#帧数据区" class="headerlink" title="帧数据区"></a>帧数据区</h4><p>&emsp;&emsp;帧数据区是用来保存一些可支持常量池解析、正常方法返回和异常处理等的数据。大部分Java字节码指令需要进行常量池访问，在帧数据区中保存这访问常量池的指针，方便程序访问常量池。<br>&emsp;&emsp;此外，当方法返回或出现异常时，虚拟机必须恢复调用者方法的栈帧，并让方法继续执行。对于异常处理，可以参考如下代码：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleOperandStack</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">10</span>, b = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> c = a / b;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>&emsp;&emsp;当程序执行到 <strong>a / b</strong> 这一步时，因为 “0” 不能作为除数，因此程序将抛出错误。可以通过 <code>javap -c Main xxx.class</code> 这段指令来查看编译信息。<br><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">public static void main(java.lang.String[]);</span><br><span class="line">   Code:</span><br><span class="line">      <span class="number">0</span>: bipush        <span class="number">10</span></span><br><span class="line">      <span class="number">2</span>: istore_1</span><br><span class="line">      <span class="number">3</span>: iconst_0</span><br><span class="line">      <span class="number">4</span>: istore_2</span><br><span class="line">      <span class="number">5</span>: iload_1</span><br><span class="line">      <span class="number">6</span>: iload_2</span><br><span class="line">      <span class="number">7</span>: idiv</span><br><span class="line">      <span class="number">8</span>: istore_3</span><br><span class="line">      <span class="number">9</span>: <span class="keyword">goto</span>          <span class="number">17</span></span><br><span class="line">     <span class="number">12</span>: astore_3</span><br><span class="line">     <span class="number">13</span>: aload_3</span><br><span class="line">     // Method java/lang/Exception.printStackTrace:()V</span><br><span class="line">     <span class="number">14</span>: invokevirtual #<span class="number">3</span>                  </span><br><span class="line">     <span class="number">17</span>: <span class="keyword">return</span></span><br><span class="line">   Exception table:</span><br><span class="line">      from    <span class="keyword">to</span>  target <span class="built_in">type</span></span><br><span class="line">          <span class="number">5</span>     <span class="number">9</span>    <span class="number">12</span>   Class java/lang/Exception</span><br></pre></td></tr></table></figure><br>&emsp;&emsp;通过观察上表，我们可以得出：程序在字节码偏移量 5 ~ 9 字节可能抛出异常，如果遇到异常，则跳转到 字节码偏移量 12 处继续执行。当方法抛出异常时，虚拟机就会查找类似的异常表来处理，如果无法在异常表中找到合适的处理方法，则会结束当前的方法调用，返回调用方法，并在调用方法中抛出相同的异常，并查找调用方法的异常表进行处理。</p>
<h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p>&emsp;&emsp;和Java堆一样，方法区也是一块<strong>所有线程共享</strong>的内存区域，它用于存放 <strong>Class</strong> 的相关信息，如类名、访问修饰符、方法描述、字段描述、常量池等。方法区的大小决定了系统可以保存的类的个数，如果程序定义了太多的类，导致方法区溢出，虚拟机同样会抛出内存溢出异常。<br>&emsp;&emsp;在 jdk 1.6、jdk 1.7 版本中，方法区又可称为永久区 ( Prem )。永久区可以使用参数-XX:PermSize 和 -XX:MaxPermSize 来设置，默认情况下，最大永久区为64MB。为了确保不发生永久区内存溢出，我们需要设置一个合理的永久区大小，保证程序的正常运行。下面，我们通过一段代码，来模拟永久区内存溢出异常。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过不停的加载class来模拟方法区溢出(jdk1.8版本被弃用, 程序运行将不会报错, 因为永久代已被删除)</span></span><br><span class="line"><span class="comment"> * VM Args: -XX:+PrintGCDetails -XX:PermSize=5m -XX:MaxPermSize=5m</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaMethodAreaOOM</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">                enhancer.setSuperclass(JavaMethodAreaOOM<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">                enhancer.setUseCache(<span class="keyword">false</span>);</span><br><span class="line">                enhancer.setCallback(<span class="keyword">new</span> MethodInterceptor() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> methodProxy.invokeSuper(o, objects);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">                enhancer.create();</span><br><span class="line">                ++i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"total create count: "</span> + i);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br>&emsp;&emsp;代码中，指定了初始永久区为 5MB，最大永久区为 5MB。因此当5MB内存空间耗尽时，系统将抛出内存溢出异常。然后，我们借用 <strong>Cglib 库</strong>来反复动态生成一个类，以及一个类的实例对象，直到抛出方法区的内存溢出异常。执行程序后，部分输入如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[Full GC </span><br><span class="line">    [PSYoungGen: <span class="number">0</span>K-&gt;<span class="number">0</span>K(<span class="number">41984</span>K)] </span><br><span class="line">    [ParOldGen: <span class="number">895</span>K-&gt;<span class="number">894</span>K(<span class="number">286720</span>K)] <span class="number">895</span>K-&gt;<span class="number">894</span>K(<span class="number">328704</span>K) </span><br><span class="line">    [PSPermGen: <span class="number">4095</span>K-&gt;<span class="number">4089</span>K(<span class="number">4096</span>K)], <span class="number">0.0082080</span> secs</span><br><span class="line">] </span><br><span class="line">[Times: user=<span class="number">0.03</span> sys=<span class="number">0.00</span>, real=<span class="number">0.01</span> secs] </span><br><span class="line"></span><br><span class="line">total create count: <span class="number">59</span></span><br><span class="line"></span><br><span class="line">Heap</span><br><span class="line"> PSYoungGen      total <span class="number">54784</span>K, used <span class="number">1075</span>K [<span class="number">0x00000007d5500000</span>, <span class="number">0x00000007d9000000</span>, <span class="number">0x0000000800000000</span>)</span><br><span class="line">  eden space <span class="number">53760</span>K, <span class="number">2</span>% used [<span class="number">0x00000007d5500000</span>,<span class="number">0x00000007d560cd20</span>,<span class="number">0x00000007d8980000</span>)</span><br><span class="line">  from space <span class="number">1024</span>K, <span class="number">0</span>% used [<span class="number">0x00000007d8980000</span>,<span class="number">0x00000007d8980000</span>,<span class="number">0x00000007d8a80000</span>)</span><br><span class="line">  to   space <span class="number">1024</span>K, <span class="number">0</span>% used [<span class="number">0x00000007d8f00000</span>,<span class="number">0x00000007d8f00000</span>,<span class="number">0x00000007d9000000</span>)</span><br><span class="line"> ParOldGen       total <span class="number">1397760</span>K, used <span class="number">673</span>K [<span class="number">0x0000000780000000</span>, <span class="number">0x00000007d5500000</span>, <span class="number">0x00000007d5500000</span>)</span><br><span class="line">  object space <span class="number">1397760</span>K, <span class="number">0</span>% used [<span class="number">0x0000000780000000</span>,<span class="number">0x00000007800a87c0</span>,<span class="number">0x00000007d5500000</span>)</span><br><span class="line"> PSPermGen       total <span class="number">4096</span>K, used <span class="number">4095</span>K [<span class="number">0x000000077fc00000</span>, <span class="number">0x0000000780000000</span>, <span class="number">0x0000000780000000</span>)</span><br><span class="line">  object space <span class="number">4096</span>K, <span class="number">99</span>% used [<span class="number">0x000000077fc00000</span>,<span class="number">0x000000077fffffe8</span>,<span class="number">0x0000000780000000</span>)</span><br><span class="line"></span><br><span class="line">Caused by: java.lang.OutOfMemoryError: PermGen space</span><br></pre></td></tr></table></figure><br>&emsp;&emsp;可以看到，当生成 59 个类后，程序便抛出了内存溢出异常( <strong>OutOfMemoryError</strong> )。此时，永久区( <strong>PSPermGen</strong> )的利用率达到了 99%，5MB 的内存空间已经几乎被使用光了。<br>&emsp;&emsp;因为永久区在 <strong>jdk 1.8</strong> 版本便被删除了，取而代之的是元数据区，而元数据区的大小我们可以用参数 <code>MetaspaceSize 和 MaxMetaspaceSize</code> 来指定。这是一块堆外的内存，因此，如果不指定大小，默认情况下虚拟机会耗尽所有可用的系统内存。下面，我们利用上面的代码，只需更改下 jdk 版本和虚拟机参数，即可得到以下部分输出：<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">[<span class="function">Full <span class="title">GC</span> <span class="params">(Last ditch collection)</span> </span></span><br><span class="line"><span class="function">    [PSYoungGen: 0K-&gt;0<span class="title">K</span><span class="params">(<span class="number">152576</span>K)</span>] </span></span><br><span class="line"><span class="function">    [ParOldGen: 1471K-&gt;1471<span class="title">K</span><span class="params">(<span class="number">308224</span>K)</span>] 1471K-&gt;1471<span class="title">K</span><span class="params">(<span class="number">460800</span>K)</span>, </span></span><br><span class="line"><span class="function">    [Metaspace: 8674K-&gt;8674<span class="title">K</span><span class="params">(<span class="number">1058816</span>K)</span>], 0.0058397 secs</span></span><br><span class="line"><span class="function">] </span></span><br><span class="line"><span class="function">[Times: user</span>=<span class="number">0.02</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line"></span><br><span class="line">total create count: <span class="number">369</span></span><br><span class="line"></span><br><span class="line">Heap</span><br><span class="line"> PSYoungGen      total <span class="number">182784</span>K, used <span class="number">3805</span>K [<span class="number">0x00000007d5380000</span>, <span class="number">0x00000007e0900000</span>, <span class="number">0x00000007ffe00000</span>)</span><br><span class="line">  eden space <span class="number">180736</span>K, <span class="number">2</span>% used [<span class="number">0x00000007d5380000</span>,<span class="number">0x00000007d57376d8</span>,<span class="number">0x00000007e0400000</span>)</span><br><span class="line">  from space <span class="number">2048</span>K, <span class="number">0</span>% used [<span class="number">0x00000007e0700000</span>,<span class="number">0x00000007e0700000</span>,<span class="number">0x00000007e0900000</span>)</span><br><span class="line">  to   space <span class="number">2560</span>K, <span class="number">0</span>% used [<span class="number">0x00000007e0400000</span>,<span class="number">0x00000007e0400000</span>,<span class="number">0x00000007e0680000</span>)</span><br><span class="line"> ParOldGen       total <span class="number">1398272</span>K, used <span class="number">1444</span>K [<span class="number">0x000000077fe00000</span>, <span class="number">0x00000007d5380000</span>, <span class="number">0x00000007d5380000</span>)</span><br><span class="line">  object space <span class="number">1398272</span>K, <span class="number">0</span>% used [<span class="number">0x000000077fe00000</span>,<span class="number">0x000000077ff693c8</span>,<span class="number">0x00000007d5380000</span>)</span><br><span class="line"> Metaspace       used <span class="number">8706</span>K, capacity <span class="number">10102</span>K, committed <span class="number">10240</span>K, reserved <span class="number">1058816</span>K</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">space</span>    <span class="title">used</span> 725<span class="title">K</span>, <span class="title">capacity</span> 809<span class="title">K</span>, <span class="title">committed</span> 896<span class="title">K</span>, <span class="title">reserved</span> 1048576<span class="title">K</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line">Caused by: java.lang.OutOfMemoryError: Metaspace</span><br></pre></td></tr></table></figure><br>&emsp;&emsp;可以看到，当生成 369 个类后，程序便抛出了内存溢出异常( <strong>OutOfMemoryError</strong> )。但之前不同的是，元数据发生溢出，虚拟机抛出异常的异常会显示 <strong>Metaspace</strong>，而永久代是 <strong>PermGen space</strong>。</p>
<h3 id="Java堆、Java栈和方法区之间的关系"><a href="#Java堆、Java栈和方法区之间的关系" class="headerlink" title="Java堆、Java栈和方法区之间的关系"></a>Java堆、Java栈和方法区之间的关系</h3><p>&emsp;&emsp;最后，我们通过下面一个简单的示例，来展示下这三者之间存在的关系。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleHeap</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SimpleHeap</span><span class="params">(<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"id: "</span> + id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        SimpleHeap s1 = <span class="keyword">new</span> SimpleHeap(<span class="number">1</span>);</span><br><span class="line">        SimpleHeap s2 = <span class="keyword">new</span> SimpleHeap(<span class="number">2</span>);</span><br><span class="line">        s1.show();</span><br><span class="line">        s2.show();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>&emsp;&emsp;上述代码首先是声明了一个 SimpleHeap 类，并在 main( ) 方法中实例化了两个 SimpleHeap 类对象。此时，各局部变量和对象的关系如下图所示。SimpleHeap 对象的实例在堆中分配，描述 SimpleHeap 类的信息放在方法区，而 main( ) 方法中的 s1、s2 两个局部变量保存在Java栈中，并指向Java堆中的两个实例。</p>
<center>
    <img style="border-radius: 0.3125em; margin-top: 10px; width: 600px; height: 200px; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src="https://blog-1253514421.cos.ap-shanghai.myqcloud.com/20200716102039.png">
    <br>
</center>]]></content>
      <categories>
        <category>JVM</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>JetBrains 白嫖三个月激活码活动(二)</title>
    <url>/2020/03/12/jetbrains-quest-second-prize/</url>
    <content><![CDATA[<p>&emsp;&emsp;本篇紧跟上篇主题，是<strong>JetBrains</strong>新发布的第二个任务。让我们瞧一瞧新任务所带来了些什么有意思的题目吧。</p>
<h3 id="谜题一"><a href="#谜题一" class="headerlink" title="谜题一"></a>谜题一</h3><p>&emsp;&emsp;在北京时间2020年3月11日19点，JetBrains 公司又在官方推特发布了第二个<a href="https://twitter.com/jetbrains/status/1237694815283879943" target="_blank" rel="noopener">活动线索</a>。</p>
<center>
    <img style="border-radius: 0.3125em; margin-top: 10px; width: 600px; height: 250px; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src="https://blog-1253514421.cos.ap-shanghai.myqcloud.com/20200312051510.png">
    <br>
</center>

<p>&emsp;&emsp;这次与之前不同的是，初看会以为他们竟然是发的是一条莫名其妙的推，但是静下心来仔细观察下，马上就能有思路了，可以说这题比活动一的简单了。为什么这么讲呢？其实观察这条推文，我们可以发现顺着读我们是没办法理解它的意思的，但是一旦我们反着读，那么马上就能知道这条推文所想表达的意思了。于是我就简单的反转了下字符串，得到下图中的信息。</p>
<center>
    <img style="border-radius: 0.3125em; margin-top: 10px; width: 600px; height: 60px; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src="https://blog-1253514421.cos.ap-shanghai.myqcloud.com/20200312052353.png">
    <br>
</center>

<p>&emsp;&emsp;图中，首先我们可得到第一个线索：<strong>product domain-specific language</strong>，而与这条信息有关的只有MPS这款产品的<a href="https://www.jetbrains.com/mps/" target="_blank" rel="noopener">主页</a>。然后，第二个线索是： <strong>Dutch tax</strong>，虽然我自始自终都没搞懂第二句话是什么意思，但还是靠这个关键字在页面上找到唯一与<strong>Dutch tax</strong>相关的地方，如下图。</p>
<center>
    <img style="border-radius: 0.3125em; margin-top: 10px; width: 600px; height: 150px; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src="https://blog-1253514421.cos.ap-shanghai.myqcloud.com/20200312053717.png">
    <br>
</center>

<a id="more"></a>
<p>而第三个线索(那便是最后一句话)便是: 藏木于林。根据官方的提示，我们可以想到，要隐藏一段文字，那最好的方法便是将其融入背景，于是<strong>Cmd/Ctrl+A</strong>这个小提示便用上了。最后，我们便得到了这么一句话: <strong>This is our 20th year as a company,we have shared numbers in our JetBrains Annual report, sharing the section with 18,650 numbers will progress your quest.</strong></p>
<center>
    <img style="border-radius: 0.3125em; margin-top: 10px; width: 600px; height: 180px; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src="https://blog-1253514421.cos.ap-shanghai.myqcloud.com/20200312054706.png">
    <br>
</center>

<h3 id="谜题二"><a href="#谜题二" class="headerlink" title="谜题二"></a>谜题二</h3><p>&emsp;&emsp;根据谜题一得到的线索，我们打开google直接搜<strong>JetBrains 2019 Annual Report</strong>，于是得到了谜题二线索所在的页面。根据官方提示，我们得知通往下一关的钥匙肯定与18，650和section分享有关。而该页面唯一与这两个点有联系的，那便是<strong>7th Annual Hackathon</strong>这部分内容。整页只有这块内容是有分享按钮的，且当我们把这部分的数字全部相加时，会发现结果刚好等于18，650。因此，我们便得到了前往谜题三的钥匙：<code>I have found the JetBrains Quest! Sometimes you just need to look closely at the Haskell language, Hello,World! in the hackathon lego brainstorms project https://blog.jetbrains.com/blog/2019/11/22/jetbrains-7th-annual-hackathon/ #JetBrainsQuest https://www.jetbrains.com/company/annualreport/2019/ via @JetBrains</code></p>
<center>
    <img style="border-radius: 0.3125em; margin-top: 10px; width: 400px; height: 300px; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src="https://blog-1253514421.cos.ap-shanghai.myqcloud.com/20200312060418.png">
    <br>
</center>

<h3 id="谜题三"><a href="#谜题三" class="headerlink" title="谜题三"></a>谜题三</h3><p>&emsp;&emsp;谜题三其实十分简单，线索也都在谜题三的答案中给我们了。首先，我们进入谜题三所给的网站，然后找到<strong>lego brainstorms</strong>这部分。观察这部分的内容，我们会发现图片中存在着这样一段文字：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">d1D j00 kN0w J378r41n2 12 4lW4Y2 H1R1N9? ch3CK 0u7 73h K4r33r2 P493 4nD 533 1f 7H3r3 12 4 J08 F0r J00 0R 4 KW357 cH4LL3n93 70 90 fUr7h3r @ l3457.</span><br></pre></td></tr></table></figure><br>这句话其实是英语火星文，翻译过来便是：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Did you know Jetbrains is always hiring? Check out the careers page and see if there is a job for you or for quest challenge to go further atleast.</span><br></pre></td></tr></table></figure></p>
<center>
    <img style="border-radius: 0.3125em; margin-top: 10px; width: 400px; height: 300px; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src="https://blog-1253514421.cos.ap-shanghai.myqcloud.com/20200312062210.png">
    <br>
</center>

<h3 id="谜题四"><a href="#谜题四" class="headerlink" title="谜题四"></a>谜题四</h3><p>&emsp;&emsp;根据谜底三，我们直接进入 Jetbrains 的 <a href="https://www.jetbrains.com/careers/jobs/" target="_blank" rel="noopener">Job 页面</a>。当我们在Role选项框中选中<strong>any</strong>选项后，便得到了前进的线索。</p>
<center>
    <img style="border-radius: 0.3125em; margin-top: 10px; width: 400px; height: 100px; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src="https://blog-1253514421.cos.ap-shanghai.myqcloud.com/20200312063737.png">
    <br>
</center>

<p>&emsp;&emsp;点击该页面后，在跳转的页面中，我们可以找到通往谜题五的线索，便是：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">To progress with your quest what you’ll need:</span><br><span class="line">To check out what we have for game developers.</span><br><span class="line">Be geeky enough to remember how you used to cheat at Konami games.</span><br><span class="line">Try cheating on the page.</span><br></pre></td></tr></table></figure></p>
<h3 id="谜题五"><a href="#谜题五" class="headerlink" title="谜题五"></a>谜题五</h3><p>&emsp;&emsp;根据提示，我们打开进入谜题五的<a href="https://www.jetbrains.com/gamedev/" target="_blank" rel="noopener">页面</a>。此题的关键在于我们要知道科乐美的作弊码：<strong>↑↑↓↓←→←→BA</strong>(这秘籍应该没人不知道吧。在该页面中完成该秘籍后，会弹出一个弹球小游戏。击碎所有方块后，我们便能得到本次活动的激活码了。</p>
<center>
    <img style="border-radius: 0.3125em; margin-top: 10px; width: 400px; height: 200px; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src="https://blog-1253514421.cos.ap-shanghai.myqcloud.com/20200312064750.png">
    <br>
</center>

<h3 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h3><p>&emsp;&emsp;Jetbrains 这两个活动都挺有趣的，唯一令人难受的就是，想要能快速完美的解出每个问题，对于个人的英语水平要求真的有点高。反正有几个谜题我是一开始根本就没完全看懂。<br>&emsp;&emsp;最后附上领取成功的截图：</p>
<center>
    <img style="border-radius: 0.3125em; margin-top: 10px; width: 600px; height: 150px; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src="https://blog-1253514421.cos.ap-shanghai.myqcloud.com/20200312065540.png">
    <br>
</center>
]]></content>
      <categories>
        <category>日常折腾</category>
      </categories>
      <tags>
        <tag>白嫖</tag>
      </tags>
  </entry>
  <entry>
    <title>JetBrains 白嫖三个月激活码活动(一)</title>
    <url>/2020/03/11/jetbrains-quest-first-prize/</url>
    <content><![CDATA[<h3 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h3><p>&emsp;&emsp;今天下午突然收到朋友发来一个链接，是<strong>JetBrains</strong>公司发的一条<a href="https://twitter.com/jetbrains/status/1236986174075482113" target="_blank" rel="noopener">推特</a>。一开始我还是云里雾里的，结果后面听朋友讲，是JetBrains公司发起的一个小活动，可以白嫖三个月激活码。虽然我自己用的是学生账号，并不需要激活码，但是闲着无聊，还是去参加了这个小活动，其实还挺有意思的(可以看成是一个小型CTF比赛吧,2333。</p>
<center>
    <img style="border-radius: 0.3125em; margin-top: 10px; width: 600px; height: 250px; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src="https://blog-1253514421.cos.ap-shanghai.myqcloud.com/20200311180319.png">
    <br>
</center>

<a id="more"></a>
<h3 id="解谜"><a href="#解谜" class="headerlink" title="解谜"></a>解谜</h3><p>&emsp;&emsp;整个活动由好几个谜题构成，下面我们就一个一个谜题展开来慢慢叙述吧。</p>
<h4 id="谜题一"><a href="#谜题一" class="headerlink" title="谜题一"></a>谜题一</h4><p>&emsp;&emsp;第一个谜题其实就是解出上面推特中的隐藏信息。相信稍微了解<strong>CTF</strong>内容的人，都能很快的猜到，这串数字肯定是能转译成文字的（要不然根本没法往下面解啊。于是，我试了下将其翻译成<strong>ascii</strong>，结果还真一次就过了（随便搜一个十六进制转ascii码的网站就行了）。于是，我们便有了下一步的思路，那便是线索就在官网的代码中。</p>
<center>
    <img style="border-radius: 0.3125em; margin-top: 10px; width: 600px; height: 250px; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src="https://blog-1253514421.cos.ap-shanghai.myqcloud.com/20200311181101.png">
    <br>
</center>

<h4 id="谜题二"><a href="#谜题二" class="headerlink" title="谜题二"></a>谜题二</h4><p>&emsp;&emsp;前往下一个阶段的线索，就出在 JetBrains 官网的源码中。首先，我们进入 <a href="https://www.jetbrains.com/" target="_blank" rel="noopener">JetBrains 官网首页</a>，然后右键获取网页的源代码。当你看到源码的时候，肯定会一脸头疼，毕竟你要从中找到一个还不知道是什么的线索。但是，可能是官方也并不想游戏难度太大，只要你有足够的耐心，慢慢往下找，你会很快就找到谜题二的答案。</p>
<center>
    <img style="border-radius: 0.3125em; margin-top: 10px; width: 600px; height: 200px; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src="https://blog-1253514421.cos.ap-shanghai.myqcloud.com/20200311181949.png">
    <br>
</center>

<h4 id="谜题三"><a href="#谜题三" class="headerlink" title="谜题三"></a>谜题三</h4><p>&emsp;&emsp;从上图我圈出来的文字中可以得知，JetBrains有很多产品，但是在他们的 “ 产品 “ 页面上有一个看起来像个玩笑，我们需要找到它，而且他们还提醒，使用<strong>chrome的隐身模式</strong>。于是，我们打开隐身模式，进入到<a href="https://www.jetbrains.com/products.html" target="_blank" rel="noopener">产品页面</a>。在众多产品中，我们可以发现这么一个异类(下图中我已圈出)。为什么这么讲呢，因为大家可以观察其他产品都会介绍该产品是干什么的，而只有<strong>JK</strong>这个应用，只有<strong>Dare to learn more</strong>这行字，而JK这两个字容易让人联想到<strong>Joke</strong>这个词，因此我们尝试的去点击下它，获取到了前往下一阶段的线索。</p>
<center>
    <img style="border-radius: 0.3125em; margin-top: 10px; width: 600px; height: 300px; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src="https://blog-1253514421.cos.ap-shanghai.myqcloud.com/20200311182540.png">
    <br>
</center>

<h4 id="谜题四"><a href="#谜题四" class="headerlink" title="谜题四"></a>谜题四</h4><p>&emsp;&emsp;前三个谜题，都可谓没什么难度，但是最后几个就开始稍微有点意思了。第四个的问题，就在点击<strong>JK</strong>产品后弹出的信息框中。</p>
<center>
    <img style="border-radius: 0.3125em; margin-top: 10px; width: 600px; height: 300px; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src="https://blog-1253514421.cos.ap-shanghai.myqcloud.com/20200311183212.png">
    <br>
</center>

<p>&emsp;&emsp;由内容可知，他们给出了一个链接（ <a href="https://jb.gg/###" target="_blank" rel="noopener">https://jb.gg/###</a> ），但是该链接目前有三位数字不知道。而我们的任务就是解答出他下面的问题：500 - 5000之间的<strong>质数</strong>有多少个。这里，我用欧拉筛快速查了遍，于是<a href="https://jb.gg/574" target="_blank" rel="noopener">前往第五个谜题的线索</a>就有了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int MAXN &#x3D; 10000000 + 5;</span><br><span class="line"></span><br><span class="line">int book[MAXN], vis[MAXN];</span><br><span class="line"></span><br><span class="line">void find(int num) &#123;</span><br><span class="line">    int ct &#x3D; 1;</span><br><span class="line">    book[1] &#x3D; 2;</span><br><span class="line">    vis[1] &#x3D; 1;</span><br><span class="line">    for (int i &#x3D; 2; i &lt;&#x3D; num; i++) &#123;</span><br><span class="line">        if (!vis[i])</span><br><span class="line">            book[ct++] &#x3D; i;</span><br><span class="line">        for (int j &#x3D; 1; j &lt;&#x3D; ct &amp;&amp; i * book[j] &lt;&#x3D; num; j++) &#123;</span><br><span class="line">            vis[i * book[j]] &#x3D; 1;</span><br><span class="line">            if (i % book[j] &#x3D;&#x3D; 0)</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    find(5000);</span><br><span class="line">    int cnt &#x3D; 0;</span><br><span class="line">    for (int i &#x3D; 500; i &lt;&#x3D; 5000; ++i)</span><br><span class="line">        if (!vis[i])</span><br><span class="line">            ++cnt;</span><br><span class="line">    cout &lt;&lt; cnt &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="谜题五"><a href="#谜题五" class="headerlink" title="谜题五"></a>谜题五</h4><p>&emsp;&emsp;这个谜题其实我是没有解出来，是特意去查了下的，因为该阶段需要你比较了解<strong>JetBrains</strong>的产品内容，而我对于 JetBrains 并不熟悉，只用过几款产品罢了。 </p>
<center>
    <img style="border-radius: 0.3125em; margin-top: 10px; width: 600px; height: 500px; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src="https://blog-1253514421.cos.ap-shanghai.myqcloud.com/20200311184027.png">
    <br>
</center>

<p>&emsp;&emsp;即便是像我这种不熟悉的人，也能知道谜底肯定与<strong>YT</strong>这款产品有关。但是，也仅此而已。因此我去查了查图里那串字符到底是什么意思，还真让我搜到了。<br>&emsp;&emsp;图中<strong>YT</strong>那个Logo其实是YouTrack在JebBrains网站的问题区。知道这个后，那么下面那串字符也就很容易知道是什么了，那当然就是问题的编号咯。于是，我们得到了第五个谜题的<a href="https://youtrack.jetbrains.com/issue/MPS-31816" target="_blank" rel="noopener">答案</a></p>
<center>
    <img style="border-radius: 0.3125em; margin-top: 10px; width: 600px; height: 100px; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src="https://blog-1253514421.cos.ap-shanghai.myqcloud.com/20200311185056.png">
    <br>
</center>

<h4 id="谜题六"><a href="#谜题六" class="headerlink" title="谜题六"></a>谜题六</h4><p>&emsp;&emsp;这个谜题就是我们最后一个需要解答的问题了，答出后我们就能获取到三个月的激活码了。谜题是官方给出的一句话：<strong>The key is to think back to the beginning.” – The JetBrains Quest team</strong> 和一长串字符(乱码?)：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Qlfh$#Li#|rx#duh#uhdglqj#wklv#|rx#pxvw#kdyh#zrunhg#rxw#krz#wr#ghfu|sw#lw1#Wklv#lv#rxu#lvvxh#wudfnhu#ghvljqhg#iru#djloh#whdpv1#Lw#lv#iuhh#iru#xs#wr#6#xvhuv#lq#Forxg#dqg#iru#43#xvhuv#lq#Vwdqgdorqh&#x2F;#vr#li#|rx#zdqw#wr#jlyh#lw#d#jr#lq#|rxu#whdp#wkhq#zh#wrwdoo|#uhfrpphqg#lw1#|rx#kdyh#ilqlvkhg#wkh#iluvw#Txhvw&#x2F;#qrz#lw“v#wlph#wr#uhghhp#|rxu#iluvw#sul&#125;h1#Wkh#frgh#iru#wkh#iluvw#txhvw#lv#‟WkhGulyhWrGhyhors†1#Jr#wr#wkh#Txhvw#Sdjh#dqg#xvh#wkh#frgh#wr#fodlp#|rxu#sul&#125;h1#kwwsv&#x3D;22zzz1mhweudlqv1frp2surpr2txhvw2</span><br></pre></td></tr></table></figure><br>&emsp;&emsp;在这个谜题里，官方告诉我们解题的关键便是要重新去思考。看到这，官方在谜题二中挖的一个坑在便被填上了。大家可以在看看谜题二中那篇文的最后一段。下图我已用红色圈出来了，这里有个key：<strong>Good luck! == Jrrg#oxfn$</strong>，而这个key就是我们解这题的关键。</p>
<center>
    <img style="border-radius: 0.3125em; margin-top: 10px; width: 600px; height: 150px; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src="https://blog-1253514421.cos.ap-shanghai.myqcloud.com/20200311185916.png">
    <br>
</center>

<p>&emsp;&emsp;观察<strong>Good luck! == Jrrg#oxfn$</strong>这个字符串，我们可以发现它是一个等式，这便意味着我们解题的关键就在于为什么它们会相等。稍微思考片刻，我发现了一个疑点：<strong>oo</strong> —&gt; <strong>rr</strong>。凭此，我初步怀疑这是一个简单的解密题，而且还是个凯撒码。于是，我尝试着在草稿纸上模拟移位了下，发现确实如此。由此，我们就能很快的去解码官方给的那串字符了。这里我用C++简单模拟了下，如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    string str &#x3D; &quot;&quot;;&#x2F;&#x2F; 这里放官方那串字符</span><br><span class="line">    for (int i &#x3D; 0; i &lt; str.length(); ++i) &#123;</span><br><span class="line">        char c &#x3D; str[i];</span><br><span class="line">        if (isalpha(c)) &#123;</span><br><span class="line">            c -&#x3D; 3;</span><br><span class="line">            if ((c &gt;&#x3D; 62 &amp;&amp; c &lt; 65) || (c &gt; 94 &amp;&amp; c &lt; 97))</span><br><span class="line">                c +&#x3D; 26;</span><br><span class="line">            else if ((c &gt; 90 &amp;&amp; c &lt;&#x3D; 93) || (c &gt; 122 &amp;&amp; c &lt;&#x3D; 125))</span><br><span class="line">                c -&#x3D; 26;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            c -&#x3D; 3;</span><br><span class="line">            if (isalpha(c))</span><br><span class="line">                c &#x3D; toupper(c);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        str[i] &#x3D; c;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>&emsp;&emsp;运行程序后，我们便完成了本次活动。从运行结果中，我们可以获得本次活动的密钥以及<a href="https://www.jetbrains.com/promo/quest/" target="_blank" rel="noopener">激活的地址</a>。这里为了保留点乐趣，我把密钥打码了，大家可以自己试试。</p>
<center>
    <img style="border-radius: 0.3125em; margin-top: 10px; width: 600px; height: 100px; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src="https://blog-1253514421.cos.ap-shanghai.myqcloud.com/20200311191201.png">
    <br>
</center>

<h3 id="领取活动奖品"><a href="#领取活动奖品" class="headerlink" title="领取活动奖品"></a>领取活动奖品</h3><p>&emsp;&emsp;打开之前获得的网址，在里面输入自己的邮箱以及刚获取到的密钥，当成功跳转到含有下面图片内容的页面时，你就成功领取到密钥了。只需稍等片刻，然后进入自己所填的邮箱找到<strong>JetBrains</strong>给你发的邮件，里面就包含了三个月的激活码。如果没看见，建议去垃圾邮件里看看。（我用的网易邮箱竟然直接把它收到垃圾邮件里去了，亏我还等了很久，因为出bug了。</p>
<center>
    <img style="border-radius: 0.3125em; margin-top: 10px; width: 600px; height: 400px; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src="https://blog-1253514421.cos.ap-shanghai.myqcloud.com/20200311191555.png">
    <br>
</center>

<p>&emsp;&emsp;最后，下面给出我收到的含有三个月激活码的邮件。</p>
<center>
    <img style="border-radius: 0.3125em; margin-top: 10px; width: 600px; height: 400px; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src="https://blog-1253514421.cos.ap-shanghai.myqcloud.com/20200311192018.png">
    <br>
</center>]]></content>
      <categories>
        <category>日常折腾</category>
      </categories>
      <tags>
        <tag>白嫖</tag>
      </tags>
  </entry>
  <entry>
    <title>macOS Catalina 10.15版本下使用Parallels 15导致电脑无声音问题</title>
    <url>/2020/03/10/parallels-voice-problem/</url>
    <content><![CDATA[<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>&emsp;&emsp;最近在使用<strong>Parallels 15</strong>时，经常发生笔记本无声音的问题。在未打开Parallels 15时，电脑声音输出是正常的，但是一打开这个软件，电脑声音就时有时无。因为我安装了<strong>Sound Control</strong>，所以我可以观察到音乐在后台是在正常播放的，但是却没办法输出，令人甚是头疼。<br><a id="more"></a></p>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>&emsp;&emsp;为了解决这个问题，我查找了挺多信息，找到了三种解决方法（确切的说是两种，因为前两种方法其实是一样的），但是却还是没整明白问题处在哪里。</p>
<h4 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h4><p>&emsp;&emsp;第一种方法就是打开电脑的<strong>Activity Monitor</strong>，然后找到<strong>coreaudiod</strong>这个进程（它是MacOS的核心音频进程），找到后将其结束即可，它在被你结束进程后，将会自动启动。</p>
<center>
    <img style="border-radius: 0.3125em; margin-top: 10px; width: 600px; height: 300px; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src="https://blog-1253514421.cos.ap-shanghai.myqcloud.com/20200310201311.png">
    <br>
</center>

<h4 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h4><p>&emsp;&emsp;第二种方法其实就是第一种方法的简化版本，它们的原理其实都是一样的，都是结束<strong>coreaudiod</strong>这个进程。首先你需要打开你的终端，然后输入：<code>sudo killall coreaudiod</code> 即可。该方法十分便捷，你可以把这个命令写成一个脚本，遇到问题时直接执行就可以了。</p>
<h4 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h4><p>&emsp;&emsp;第三种方法可以说是一劳永逸的方法（至少在我使用的这段时间，暂时没有再出现过问题）。该方法是我在<strong>Parallels</strong>官方论坛中发现的，在论坛中可以看见，有许多人都遇到了这个问题，因此看起来可能是兼容的问题？？？有兴趣的人可以浏览<a href="https://forum.parallels.com/threads/when-a-vm-starts-earpods-stops-functioning.348837/#post-862582" target="_blank" rel="noopener">链接 1 🔗</a>中的#21楼回复和<a href="https://forum.parallels.com/threads/no-sound-at-catalina-10-15-2-parallels-desktop-15-1-2-for-mac.349141/page-2" target="_blank" rel="noopener">链接 2 🔗</a>中的#18楼的回复。</p>
<p>&emsp;&emsp;下面，我将描述该如何去解决这个问题：</p>
<p>I、首先，<strong>shut down</strong>当前<strong>Parallels 15</strong>所在运行的环境。如果不知道该怎么关机的话，可以看下图。长点对应环境，就会显示操作栏，选中对应选项即可。</p>
<center>
    <img style="border-radius: 0.3125em; margin-top: 10px; width: 600px; height: 300px; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src="https://blog-1253514421.cos.ap-shanghai.myqcloud.com/20200310202746.png">
    <br>
</center>

<p>II、然后，打开当前环境的偏好设置，点击如下图选项。</p>
<center>
    <img style="border-radius: 0.3125em; margin-top: 10px; width: 200px; height: 200px; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src="https://blog-1253514421.cos.ap-shanghai.myqcloud.com/20200310203533.png">
    <br>
</center>

<p>III、在偏好设置中，找到<strong>Hardware</strong>选项，然后选中<strong>CPU&amp;Memory</strong>。点击左下角的<strong>小锁🔒</strong>，以来解锁一些操作。如果你没有执行第一步的话，这一步可能会有你需要关机才能执行某些操作的提示。最后，找到<strong>Hypervisor</strong>选项，点击下拉框，选中<strong>Apple</strong>就大功告成了。</p>
<center>
    <img style="border-radius: 0.3125em; margin-top: 10px; width: 600px; height: 400px; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src="https://blog-1253514421.cos.ap-shanghai.myqcloud.com/20200310203746.png">
    <br>
</center>

<p>Ⅳ、重启<strong>Parallels 15</strong>应用，现在你就会发现声音播放正常了（如果还是无声音的话，使用下方法一或方法二）。</p>
]]></content>
      <categories>
        <category>日常折腾</category>
      </categories>
      <tags>
        <tag>macOS</tag>
        <tag>parallels</tag>
      </tags>
  </entry>
  <entry>
    <title>白嫖教育版 Microsoft Office 365</title>
    <url>/2020/02/23/microsoft-office/</url>
    <content><![CDATA[<p>&emsp;&emsp;记录下白嫖教育版 <strong>Microsoft Office 365</strong> 的经过，方便以后如果遗忘掉，在换新机或者重装后需要再找攻略。此方法是通过教育邮箱了获取教育版的Office 365，因此该方法的优势在于只要主账号不过期，那么子账号其实是可以一直用下去的，相当于永久账号了（一次注册，永久使用。</p>
<a id="more"></a>
<h3 id="第一步：-获取临时邮箱"><a href="#第一步：-获取临时邮箱" class="headerlink" title="第一步： 获取临时邮箱"></a>第一步： 获取临时邮箱</h3><p>&emsp;&emsp;首先，我们注册教育邮箱前，需要去获取个临时的邮箱来接受验证码。这里我是去<a href="http://24mail.chacuo.net/" target="_blank" rel="noopener">查错网</a>，生成了一个临时邮箱ID，你可以用自己创建的ID，也可以用站方随机生成的ID。如下图所示，在临时邮箱ID那个框框中，自定义一个自己的ID后，点击下设置邮箱即可。</p>
<center>
    <img style="border-radius: 0.3125em; margin-top: 10px; width: 600px; height: 150px; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src="https://blog-1253514421.cos.ap-shanghai.myqcloud.com/microsoft-office-img1.png">
    <br>
</center>

<h3 id="第二部：注册-Office-365-教育版账号"><a href="#第二部：注册-Office-365-教育版账号" class="headerlink" title="第二部：注册 Office 365 教育版账号"></a>第二部：注册 Office 365 教育版账号</h3><p>&emsp;&emsp;首先，打开<strong>Office 365 教育版</strong>的<a href="https://signup.microsoft.com/signup?sku=faculty" target="_blank" rel="noopener">注册网页</a>。然后，在该网页中，你可以看见官方要求输入<strong>学校电子邮件地址</strong>的框框，这里你需要用到你在第一步申请的<strong>临时邮箱ID</strong>，例如：我在第一步中申请的临时邮箱ID - <strong>beqnlp82370</strong>。有了临时邮箱ID后，你只需在ID后跟 <strong>@stu.mao.office.gy</strong>，即 <strong>beqnlp82370@stu.mao.office.gy</strong>（这里的邮箱ID换成你自己的）。最后到达用户信息界面，如下图所示。</p>
<center>
    <img style="border-radius: 0.3125em; margin-top: 10px; width: 600px; height: 500px; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src="https://blog-1253514421.cos.ap-shanghai.myqcloud.com/microsoft-office-img2.png">
    <br>
</center>

<p>&emsp;&emsp;这里面，最重要的是这个验证码的，其他随意。验证码会发送到下图这里，大概需要五分钟以上才会接受到，因此在五分钟后，你可以时刻查看下当前的邮件数量，如果邮件数量不是0，而又页面中没有显示邮件时，刷新当前页面即可（这部分耗时最长，建议耐心等待下，我是等了快15分钟才收到注册码的。如果第一个五分钟没有收到验证码，建议重新发送注册码，然后再耐心等待，如还不行，可尝试换个临时邮箱ID）。</p>
<center>
    <img style="border-radius: 0.3125em; margin-top: 10px; width: 600px; height: 250px; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src="https://blog-1253514421.cos.ap-shanghai.myqcloud.com/microsoft-office-img3.png">
    <br>
</center>

<h3 id="第三步：访问面板组"><a href="#第三步：访问面板组" class="headerlink" title="第三步：访问面板组"></a>第三步：访问面板组</h3><p>&emsp;&emsp;首先进入<a href="https://account.activedirectory.windowsazure.com/r#/groups" target="_blank" rel="noopener">面板组</a>，然后找到<strong>我加入的组</strong>这一栏，你会发现当前<strong>我加入的组</strong>为空，此时你就需要点击<strong>加入组</strong>，找到<strong>Office 365</strong>这个组，点击加入组，在弹出来的框中任意输入提交即可，管理员会自动审核通知，因此你会秒进组。操作到这一步，你就已经完成的差不多了。</p>
<center>
    <img style="border-radius: 0.3125em; margin-top: 10px; width: 600px; height: 400px; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src="https://blog-1253514421.cos.ap-shanghai.myqcloud.com/microsoft-office-img4.png">
    <br>
</center>

<h3 id="第四步：下载-Office-365"><a href="#第四步：下载-Office-365" class="headerlink" title="第四步：下载 Office 365"></a>第四步：下载 Office 365</h3><p>&emsp;&emsp;打开 Office 365 的<a href="https://signup.microsoft.com/" target="_blank" rel="noopener">登录网址</a>，输入你之前注册的账号密码后，他会跳转到绑定手机号的页面，如下图所示。你可以绑定，也可以不绑定（点击取消即可），不绑定的话，你每次登录都可能会重定向到该页面，这里看个人喜好吧。</p>
<center>
    <img style="border-radius: 0.3125em; margin-top: 10px; width: 600px; height: 200px; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src="https://blog-1253514421.cos.ap-shanghai.myqcloud.com/microsoft-office-img5.png">
    <br>
</center>

<p>&emsp;&emsp;之后，进入 Office 365 的主页，下载安装自己需要的应用。安装好后，登录自己的教育邮箱账号便可以安心使用了。</p>
<center>
    <img style="border-radius: 0.3125em; margin-top: 10px; width: 600px; height: 400px; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src="https://blog-1253514421.cos.ap-shanghai.myqcloud.com/microsoft-office-img6.png">
    <br>
</center>


<h3 id="注意事项-一定要看"><a href="#注意事项-一定要看" class="headerlink" title="注意事项(一定要看)"></a>注意事项(一定要看)</h3><p>&emsp;&emsp;因为用的是教育邮箱，主账号(即管理员账号)是可以看到<strong>所有人</strong>的 <strong>OneDrive</strong> 内容的，因此千万不要往该账号的 OneDrive 中上传个人资料，以免造成不可挽回的损失。你可以将 OneDrive 账号替换成个人私用的，这样的话，就可避免上述问题。</p>
]]></content>
      <categories>
        <category>日常折腾</category>
      </categories>
      <tags>
        <tag>白嫖</tag>
      </tags>
  </entry>
  <entry>
    <title>最大子序列和</title>
    <url>/2020/02/15/maxSubSeqSum/</url>
    <content><![CDATA[<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>给定一个包含N个整数的序列：<script type="math/tex">\{A_1, A_2, A_3……A_N\}，</script> 求该序列中的子序列的最大和，即：<script type="math/tex">sum = max(0, \sum_j^{k=i}A_k)</script></p>
<h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h4><p><strong>input</strong>: 4, -3, 5, -2, -1, 2, 6, -2<br><strong>output</strong>: 11</p>
<a id="more"></a>
<h3 id="暴力法一"><a href="#暴力法一" class="headerlink" title="暴力法一"></a>暴力法一</h3><p>&emsp;&emsp;暴力法一是最简单粗暴的方法，通过三重嵌套循环，枚举每个子序列的大小，然后记录并返回最终值，其复杂度: <strong>O(n^3)</strong>。<br>&emsp;&emsp;第一个循环 <strong>i</strong> 指定子列左端的下标，第二个循环 <strong>j</strong> 指定子列右端的下标，第三个循环 <strong>k</strong> 用来累加计算 i-&gt;j 的和，<strong>thisSum</strong> 记录A[i]-&gt; A[j]的子列和，<strong>maxSum</strong> 记录最大的累加和。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int maxSubSeqSum(int A[], int N) &#123;</span><br><span class="line">    int thisSum, maxSum &#x3D; 0;</span><br><span class="line">    int i, j, k;</span><br><span class="line"></span><br><span class="line">    for (i &#x3D; 0; i &lt; N; ++i) &#123;</span><br><span class="line">        for (j &#x3D; i; j &lt; N; ++j) &#123;</span><br><span class="line">            thisSum &#x3D; 0;</span><br><span class="line">            for (k &#x3D; i; k &lt;&#x3D; j; ++k) &#123;</span><br><span class="line">                thisSum +&#x3D; A[k];</span><br><span class="line">                if (thisSum &gt; maxSum)</span><br><span class="line">                    maxSum &#x3D; thisSum;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return maxSum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="暴力法二"><a href="#暴力法二" class="headerlink" title="暴力法二"></a>暴力法二</h3><p>&emsp;&emsp;暴力法二是在暴力法一的基础上进行了优化，将三重循环减到两重，大大减少了循环次数，因此其复杂度: <strong>O(n^2)</strong>。<br>&emsp;&emsp;这个方法少了第 k 个循环，合理优化了代码，对于相同的 i ，不同的 j ，只需<strong>在 j-1 次的基础上累加当前项</strong>即可。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int maxSubSeqSum(int A[], int N) &#123;</span><br><span class="line">    int thisSum, maxSum &#x3D; 0;</span><br><span class="line">    int i, j;</span><br><span class="line"></span><br><span class="line">    for (i &#x3D; 0; i &lt; N; ++i) &#123;</span><br><span class="line">        thisSum &#x3D; 0;</span><br><span class="line">        for (j &#x3D; i; j &lt; N; ++j) &#123;</span><br><span class="line">            thisSum +&#x3D; A[j];</span><br><span class="line">            if (thisSum &gt; maxSum)</span><br><span class="line">                maxSum &#x3D; thisSum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return maxSum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="分治法"><a href="#分治法" class="headerlink" title="分治法"></a>分治法</h3><p>&emsp;&emsp;运用分而治之的思想，主要是通过<strong>递归</strong>来实现的，当数据量很大时，会占用十分大的内存消耗，因此该方法并不能很好的工作，复杂度： <strong>O(nlogn)</strong>。</p>
<p>&emsp;&emsp;<strong>解题思路</strong>：首先将整个序列不断<strong>切半分</strong>，直到得到个只含<strong>一个数的子序列</strong>，如下图所示。</p>
<center>
    <img style="border-radius: 0.3125em; margin-top: 15px; width: 500px; height: 90px; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src="https://blog-1253514421.cos.ap-shanghai.myqcloud.com/maxSubSeqSum-img1.png">
    <br>
</center>

<p>然后将其中的每个数和其左或右边的数进行<strong>相加</strong>，用相加后得到的值和原值进行<strong>比较</strong>，并<strong>保留较大的一方</strong>。例如以下图所示：4 + (-3) = 1 &lt; 4 ，保留 4; 5 + (-2) = 3 &lt; 5，保留 5 ；(-1) + 2 = 1 &lt; 2，保留 2 ； 6 + (-2) = 4 &lt; 6 ，保留 6。 这里每一步的计算，我们都要保留最大的那个和。</p>
<center>
    <img style="border-radius: 0.3125em; margin-top: 15px; width: 400px; height: 110px; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src="https://blog-1253514421.cos.ap-shanghai.myqcloud.com/maxSubSeqSum-img2.png">
    <br>
</center>

<p>利用上述的思想，重复第二步操作便可得下图结果，即左边从 4 开始向右走，不断累加到 5 便停止，最终得到的 6 便是该阶段所能获得的最大子列和；而右边因为是从 -1 开始的，当值不大于 0 时，我们不考虑，因此从 2 开始向右走， 不断累加到6便停止，最终得到的 8 便是该阶段所能得到的最大子列和，将其与左边的进行比较，保留较大的值即可。</p>
<center>
    <img style="border-radius: 0.3125em; margin-top: 15px; width: 500px; height: 130px; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src="https://blog-1253514421.cos.ap-shanghai.myqcloud.com/maxSubSeqSum-img3.png">
    <br>
</center>

<p>通过不断的回溯，最终我们需要考虑的一个跨越边界的问题，即左右两边的值相加是否能得到一个更大的值。如下图所示，从 -2 开始，一直累加到 4 为止，此时我们便能得到左侧的最大值，而从 -1 开始，一直累加到 6 为止，此时我们便能得到右侧的最大值，将它们相加与之前得到的左右两边的最大值比较，其中较大的值便是我们所求问题的答案。</p>
<center>
    <img style="border-radius: 0.3125em; margin-top: 15px; width: 500px; height: 150px; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src="https://blog-1253514421.cos.ap-shanghai.myqcloud.com/maxSubSeqSum-img4.png">
    <br>
</center>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int maxSubSeqSum(int A[], int l, int r) &#123;</span><br><span class="line">    &#x2F;&#x2F; 当分割到只剩一个元素时，</span><br><span class="line">    &#x2F;&#x2F; 判断其是否大于0，如果大于0的话就保留其值并返回，否则返回0</span><br><span class="line">    if (l &#x3D;&#x3D; r)</span><br><span class="line">        if (A[l] &gt; 0)</span><br><span class="line">            return A[l];</span><br><span class="line">        else</span><br><span class="line">            return 0;</span><br><span class="line"></span><br><span class="line">    int mid &#x3D; (l + r) &#x2F; 2;</span><br><span class="line">    &#x2F;&#x2F; 获取每个阶段左右两边的最大值</span><br><span class="line">    int maxLeftSum &#x3D; maxSubSeqSum(A, l, mid);</span><br><span class="line">    int maxRightSum &#x3D; maxSubSeqSum(A, mid + 1, r);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 计算左边子序列和的最大值</span><br><span class="line">    int maxLeftBorderSum &#x3D; 0, leftBorderSum &#x3D; 0;</span><br><span class="line">    for (int i &#x3D; mid; i &gt;&#x3D; l; --i) &#123;</span><br><span class="line">        leftBorderSum +&#x3D; A[i];</span><br><span class="line">        if (leftBorderSum &gt; maxLeftBorderSum)</span><br><span class="line">            maxLeftBorderSum &#x3D; leftBorderSum;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 计算右边子序列和的最大值</span><br><span class="line">    int maxRightBorderSum &#x3D; 0, rightBorderSum &#x3D; 0;</span><br><span class="line">    for (int i &#x3D; mid + 1; i &lt;&#x3D; r; ++i) &#123;</span><br><span class="line">        rightBorderSum +&#x3D; A[i];</span><br><span class="line">        if (rightBorderSum &gt; maxRightBorderSum)</span><br><span class="line">            maxRightBorderSum &#x3D; rightBorderSum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return max(maxLeftSum, </span><br><span class="line">            max(maxRightSum, </span><br><span class="line">                maxLeftBorderSum + maxRightBorderSum));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="扫描法"><a href="#扫描法" class="headerlink" title="扫描法"></a>扫描法</h3><p>&emsp;&emsp;因为最大连续子序列和只可能是以数组下标0～N-1中某个作为结尾。当遍历到第i个元素时，将其和当前子序列和的值(thisSum)相加，然后判断其是否大于0：如果大于0，则更新最大子序列和(maxSum)的值；否则，更新当前子序列和的值为0，算法复杂度：<strong>O(n)</strong>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int maxSubSeqSum(int A[], int N) &#123;</span><br><span class="line">    int thisSum &#x3D; 0, maxSum &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    for (int i &#x3D; 0; i &lt; N; ++i) &#123;</span><br><span class="line">        &#x2F;&#x2F; 向右累加</span><br><span class="line">        thisSum +&#x3D; A[i];</span><br><span class="line">        if (thisSum &gt; maxSum)</span><br><span class="line">            maxSum &#x3D; thisSum;</span><br><span class="line">        else if (thisSum &lt; 0)  &#x2F;&#x2F; 如果为负则舍弃</span><br><span class="line">            thisSum &#x3D; 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return maxSum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>分治</tag>
        <tag>动态规划</tag>
        <tag>扫描法</tag>
      </tags>
  </entry>
  <entry>
    <title>vscode搭建c/c++调试环境(MacOS)</title>
    <url>/2020/02/13/mac-vscode-c++/</url>
    <content><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>&emsp;&emsp;vscode相比起IDE，其轻便、插件丰富、功能繁多是我选择其作为C++日常使用的编辑器的原因。对于我这种，只写写一些简单程序，用来学习算法和数据结构，并且空闲时间，还能写写python脚本和网站，vscode可谓首选。</p>
<a id="more"></a>
<h3 id="下载与安装"><a href="#下载与安装" class="headerlink" title="下载与安装"></a>下载与安装</h3><p>&emsp;&emsp;<a href="https://code.visualstudio.com/" target="_blank" rel="noopener">vscode</a>十分的方便，直接去官网下载即可。下载后好，一路点击继续，等到安装结束即可。</p>
<center>
    <img style="border-radius: 0.3125em; margin-top: 10px; width: 400px; height: 250px; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src="https://blog-1253514421.cos.ap-shanghai.myqcloud.com/image-1-1600x667.png">
    <br>
</center>

<h3 id="插件推荐"><a href="#插件推荐" class="headerlink" title="插件推荐"></a>插件推荐</h3><h4 id="C-C"><a href="#C-C" class="headerlink" title="C/C++"></a>C/C++</h4><p>&emsp;&emsp;如果想在vscode上快速的开始使用C++编写程序，那么<strong>C/C++</strong>这款插件是微软官方发布的一款专门针对C和C++的插件。打开vscode，然后点击插件图标，在搜索框中直接搜索<strong>C/C++</strong>，下载数量和评分最高的那个就是了（一般搜出来的第一个就是）。</p>
<center>
    <img style="border-radius: 0.3125em; margin-top: 10px; width: 500px; height: 200px; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src="https://blog-1253514421.cos.ap-shanghai.myqcloud.com/BCAAAAE4-8B7F-4A42-B9FB-535725BBAADF.png">
    <br>
</center>

<h4 id="Chinese-Simplified"><a href="#Chinese-Simplified" class="headerlink" title="Chinese (Simplified)"></a>Chinese (Simplified)</h4><p>&emsp;&emsp;<strong>Chinese (Simplified)</strong> 是微软官方发布的用来解决vscode汉化问题的一款插件，如果你对满屏的英文感觉头疼的话，那建议可以尝试下安装这款插件哦，安装方式同上。</p>
<center>
    <img style="border-radius: 0.3125em; margin-top: 10px; width: 500px; height: 180px; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src="https://blog-1253514421.cos.ap-shanghai.myqcloud.com/302A82E3-752E-4C3A-BFD4-020FAA60B1F8.png">
    <br>
</center>

<h4 id="CodeLLDB"><a href="#CodeLLDB" class="headerlink" title="CodeLLDB"></a>CodeLLDB</h4><p>&emsp;&emsp;如果在Mac OS X Catalina版本上这款插件是必须安装的，不安装<strong>CodeLLDB</strong> 这款插件的话，那么你就会遇到无法调试程序这个问题。原因是苹果在macOS Catalina上取消了对lldb支持，于是我们就必须寻找对应的替代品。为了解决这个问题，我谷歌了挺久，最后在官方Github上的<a href="https://github.com/microsoft/vscode-cpptools/issues/3829" target="_blank" rel="noopener">issue</a>中发现了解决方法。官方给出的解决方法就是安装这款插件来替代X-Code中的lldb-mi。</p>
<center>
    <img style="border-radius: 0.3125em; margin-top: 10px; width: 500px; height: 180px; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src="https://blog-1253514421.cos.ap-shanghai.myqcloud.com/3BC45F5E-E5FE-49E3-9EA2-38AC26114321.png">
    <br>
</center>

<h3 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h3><p>&emsp;&emsp;首先，我们需要一个专门存放C/C++代码的地方，以后要编写C++代码时，直接在vscode打开对应的文件夹就行了。这样做的好处就是，不必反复的配置运行环境。如下图所示，<strong>.vscode</strong>这个文件夹是用来存放环境配置文件的，而<strong>demo</strong>这个文件夹，是用来存放自己的程序的，你可以创建多个类似与demo的这种文件夹。</p>
<center>
    <img style="border-radius: 0.3125em; margin-top: 10px; width: 500px; height: 180px; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src="https://blog-1253514421.cos.ap-shanghai.myqcloud.com/84451EF7-5FB4-49EE-A3CF-8A6D3578201C.png">
    <br>
</center>

<h4 id="配置-launch-json"><a href="#配置-launch-json" class="headerlink" title="配置 launch.json"></a>配置 launch.json</h4><p>&emsp;&emsp;进入左侧的调试页面，点击<strong>创建launch.json文件</strong>，就会自动在你的工作目录下新建一个.vscode文件来存放你的调试配置。这里我们选择C/C++: (lldb) Launch。</p>
<center>
    <img style="border-radius: 0.3125em; margin-top: 10px; width: 400px; height: 200px; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src="https://blog-1253514421.cos.ap-shanghai.myqcloud.com/image-5.png">
    <br>
</center>

<p>&emsp;&emsp;<strong>launch.json</strong>这个文件中的配置，<a href="https://go.microsoft.com/fwlink/?linkid=830387" target="_blank" rel="noopener">官方的文档</a>里有详细的说明。下面的配置，是我通过不断尝试所最终决定下来的。其中唯一特别的是这块：<code>&quot;program&quot;: &quot;${workspaceFolder}/tmp/${fileBasenameNoExtension}.out&quot;</code> 它会在当前目录下新建一个tmp的文件夹来存放编译后的文件，这样的好处是，有一个专门存放编译文件的地方，让程序所在的目录看起来清爽点。如果对以下配置有不接的地方，只要将<strong>鼠标长放在对应参数上</strong>就行了，它会显示出对应配置的说明。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;version&quot;: &quot;0.2.0&quot;,</span><br><span class="line">    &quot;configurations&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;preLaunchTask&quot;: &quot;c++&quot;,</span><br><span class="line">            &quot;name&quot;: &quot;(lldb) Launch&quot;,</span><br><span class="line">            &quot;type&quot;: &quot;lldb&quot;,</span><br><span class="line">            &quot;request&quot;: &quot;launch&quot;,</span><br><span class="line">            &quot;program&quot;: &quot;$&#123;workspaceFolder&#125;&#x2F;tmp&#x2F;$&#123;fileBasenameNoExtension&#125;.out&quot;,</span><br><span class="line">            &quot;args&quot;: [],</span><br><span class="line">            &quot;stopAtEntry&quot;: false,</span><br><span class="line">            &quot;cwd&quot;: &quot;$&#123;workspaceFolder&#125;&quot;,</span><br><span class="line">            &quot;environment&quot;: [],</span><br><span class="line">            &quot;externalConsole&quot;: true,</span><br><span class="line">            &quot;MIMode&quot;: &quot;lldb&quot;,</span><br><span class="line">            &quot;logging&quot;: &#123;</span><br><span class="line">                &quot;trace&quot;: true,</span><br><span class="line">                &quot;traceResponse&quot;: true,</span><br><span class="line">                &quot;engineLogging&quot;: true,</span><br><span class="line">                &quot;programOutput&quot;: true,</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="配置-task-json"><a href="#配置-task-json" class="headerlink" title="配置 task.json"></a>配置 task.json</h4><p>&emsp;&emsp;这里我们直接使用快捷键<strong>command + P</strong>，然后在弹出的搜索框中输入 <strong>&gt;task</strong> 来新建一个生成任务即可。</p>
<center>
    <img style="border-radius: 0.3125em; margin-top: 10px; width: 400px; height: 120px; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src="https://blog-1253514421.cos.ap-shanghai.myqcloud.com/1581579434251.jpg">
    <br>
</center>

<p>&emsp;&emsp;打开<strong>task.json</strong>这个文件，对其进行以下配置。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;version&quot;: &quot;2.0.0&quot;,</span><br><span class="line">    &quot;tasks&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;label&quot;: &quot;c++&quot;,</span><br><span class="line">            &quot;type&quot;: &quot;shell&quot;,</span><br><span class="line">            &quot;command&quot;: &quot;g++&quot;,</span><br><span class="line">            &quot;args&quot;: [</span><br><span class="line">                &quot;$&#123;file&#125;&quot;,</span><br><span class="line">                &quot;-std&#x3D;c++17&quot;,</span><br><span class="line">                &quot;-o&quot;,</span><br><span class="line">                &quot;$&#123;workspaceFolder&#125;&#x2F;tmp&#x2F;$&#123;fileBasenameNoExtension&#125;.out&quot;,</span><br><span class="line">                &quot;-g&quot;</span><br><span class="line">            ],</span><br><span class="line">            &quot;group&quot;: &quot;build&quot;,</span><br><span class="line">            &quot;presentation&quot;: &#123;</span><br><span class="line">                &quot;echo&quot;: true,</span><br><span class="line">                &quot;focus&quot;: false,</span><br><span class="line">                &quot;panel&quot;: &quot;shared&quot;,</span><br><span class="line">                &quot;showReuseMessage&quot;: true,</span><br><span class="line">                &quot;clear&quot;: true,</span><br><span class="line">                &quot;reveal&quot;: &quot;silent&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="测试配置"><a href="#测试配置" class="headerlink" title="测试配置"></a>测试配置</h3><p>&emsp;&emsp;上述步骤都正确完成后，那么就新建一个c++程序来测试下环境是否配置成功吧。</p>
<h4 id="编写一个简单的demo"><a href="#编写一个简单的demo" class="headerlink" title="编写一个简单的demo"></a>编写一个简单的demo</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int a &#x3D; 1;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="设置断点，并编译代码"><a href="#设置断点，并编译代码" class="headerlink" title="设置断点，并编译代码"></a>设置断点，并编译代码</h4><p>&emsp;&emsp;vscode设置断点的方式和其他IDE一样，如果是在不清楚的话，建议搜一下。然后你可以选择在调试界面中，单击<strong>运行和调试旁的三角形</strong>，也可以直接使用快捷键<strong>FN + F5</strong>来进行调试。程序编译运行后，可以在<strong>vscode左边</strong>看见对应调试信息，然后可以在<strong>vscode上边</strong>看见控制工具栏。如果这些都能看见，并且弹出对应的控制台，那么环境就配置成功了。</p>
<center>
    <img style="border-radius: 0.3125em; margin-top: 10px; width: 600px; height: 200px; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src="https://blog-1253514421.cos.ap-shanghai.myqcloud.com/1581580268989.jpg">
    <br>
</center>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>&emsp;&emsp;以上就是在Mac OS上使用vscode配置C++/C语言的开发环境。后期可以根据自己的需求，去修改配置文件对应的选项，并对vscode进行一些个性化修改就是了。经过一段时间使用，vscode在日常使用来讲，给我的感觉远比使用IDE来的舒适，因此希望你也会喜欢。</p>
]]></content>
      <categories>
        <category>日常折腾</category>
        <category>C++</category>
      </categories>
      <tags>
        <tag>vscode</tag>
        <tag>macOS</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Hexo与GitHub Pages来搭建个人博客</title>
    <url>/2020/02/06/zioang-blog/</url>
    <content><![CDATA[<h2 id="缘由"><a href="#缘由" class="headerlink" title="缘由"></a>缘由</h2><p>&emsp;&emsp;这段时间因为疫情而一直呆在家里快无聊疯了，寻思着找点事干。刚好现在准备学点东西，然后想做做笔记什么的，于是就有了这个博客的诞生。</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&emsp;&emsp;博客是由<a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">Hexo</a>与<a href="https://pages.github.com/" target="_blank" rel="noopener">GitHub Pages</a>结合搭建的一个静态网站，由于之前完全没接触过<a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">Hexo</a>这个框架，于是乎就打算以此作为博客的第一篇文章，边学习边记录，并来记录下她诞生的过程。</p>
<a id="more"></a>
<h2 id="搭建需求"><a href="#搭建需求" class="headerlink" title="搭建需求"></a>搭建需求</h2><ul>
<li>首先得有个<a href="https://github.com/" target="_blank" rel="noopener">GitHub</a>账号，登录后点击<strong>New repository</strong>来创建一个新仓库，仓库名必须为：用户名.github.io（<strong>这个用户名是你GitHub的账号名称</strong>）。下面这张图片，就是我创建的对应仓库。</li>
</ul>
<center>
    <img style="border-radius: 0.3125em; margin-top: 10px; width: 400px; height: 250px; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src="https://blog-1253514421.cos.ap-shanghai.myqcloud.com/7F609234-C606-4B5B-B2FA-FA1890A0EA0A.png">
    <br>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">仓库名</div>
</center>

<ul>
<li>安装<a href="https://git-scm.com/download/win" target="_blank" rel="noopener">Git</a>，这里对于Git的安装和配置不多介绍，善用下搜索引擎。</li>
<li>安装<a href="https://nodejs.org/en/download/" target="_blank" rel="noopener">Node.js</a>，因为我用的是MacOS系统，所以介绍下如何在Mac上安装Node.js。<ul>
<li>确保自己的电脑上有<a href="https://brew.sh/" target="_blank" rel="noopener">HomeBrew</a>，没有的话直接去打开终端然后运行这段命令：  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;usr&#x2F;bin&#x2F;ruby -e &quot;$(curl -fsSL https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;Homebrew&#x2F;install&#x2F;master&#x2F;install)&quot;</span><br></pre></td></tr></table></figure></li>
<li>接下来事情就简单了，直接在终端中有<strong>HomeBrew</strong>安装Node.js即可，输入以下命令:  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew install node</span><br></pre></td></tr></table></figure>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew install npm</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>安装<a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">Hexo</a>，因为第二步的时候已经安装好了npm，所以现在我们可以直接通过npm来安装<strong>Hexo</strong>了，在终端中输入以下命令：  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo npm install -g hexo-cli</span><br></pre></td></tr></table></figure>
<ul>
<li>这里注意下，安装过程中可能会报以下错误  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">┌───────────────────────────────────────────────────────────────────┐</span><br><span class="line">│                      npm update check failed                      │</span><br><span class="line">│                Try running with sudo or get access                │</span><br><span class="line">│               to the local update config store via                │</span><br><span class="line">│ sudo chown -R $USER:$(id -gn $USER) &#x2F;Users&#x2F;veritystothard&#x2F;.config │</span><br><span class="line">└───────────────────────────────────────────────────────────────────┘</span><br><span class="line">module.js:491</span><br><span class="line">    throw err;</span><br><span class="line">    ^</span><br><span class="line"></span><br><span class="line">Error: Cannot find module &#39;proto-list&#39;</span><br><span class="line">    at Function.Module._resolveFilename (module.js:489:15)</span><br><span class="line">    at Function.Module._load (module.js:439:25)</span><br><span class="line">    at Module.require (module.js:517:17)</span><br><span class="line">    at require (internal&#x2F;module.js:11:18)</span><br><span class="line">    at Object.&lt;anonymous&gt; (&#x2F;usr&#x2F;local&#x2F;lib&#x2F;node_modules&#x2F;npm&#x2F;node_modules&#x2F;config-chain&#x2F;index.js:1:79)</span><br><span class="line">    at Module._compile (module.js:573:30)</span><br><span class="line">    at Object.Module._extensions..js (module.js:584:10)</span><br><span class="line">    at Module.load (module.js:507:32)</span><br><span class="line">    at tryModuleLoad (module.js:470:12)</span><br><span class="line">    at Function.Module._load (module.js:462:3)</span><br><span class="line"></span><br><span class="line">其解决方法就是更改下配置权限: sudo chown -R $USER:$(id -gn $USER) ~&#x2F;.config</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h2 id="初始化博客项目"><a href="#初始化博客项目" class="headerlink" title="初始化博客项目"></a>初始化博客项目</h2><p>&emsp;&emsp;在终端中进入项目想要创建的路径，然后输入：<code>hexo init blog(这里的blog可以更改为你想要的项目名)</code> 这里有一点需要注意下的是，安装过程中可能会因<strong>xcode-select</strong>的版本而报错，因此更新下版本就好了，在终端中依次输入以下命令即可：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo rm -rf &#x2F;Library&#x2F;Developer&#x2F;CommandLineTools</span><br><span class="line">xcode-select --install</span><br></pre></td></tr></table></figure><br>&emsp;&emsp;项目安装结束后，我们来写第一篇文章来测试下效果吧。为了检测我们的网站雏形，分别按顺序输入以下三条命令（<strong>注意，所有的Hexo命令都要在对应blog的根目录出运行</strong>）：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo n first</span><br><span class="line"></span><br><span class="line">hexo g</span><br><span class="line"></span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure><br>命令运行完成后，打开浏览器输入<a href="http://127.0.0.1:4000/" target="_blank" rel="noopener">127.0.0.1:4000</a>，即可了解网站的详细内容。</p>
<center>
    <img style="border-radius: 0.3125em; margin-top: 10px; width: 600px; height: 400px; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src="https://blog-1253514421.cos.ap-shanghai.myqcloud.com/B9B73842-F4E2-449D-966B-06D7D5DAA9F6.png">
    <br>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">博客主页</div>
</center>

<p>这里的first就是我们刚刚新建的文章。</p>
<p>&emsp;&emsp;下面介绍下<strong>Hexo</strong>的常用命令：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo -g # 安装Hexo</span><br><span class="line">npm update hexo -g # 升级</span><br><span class="line">hexo init xxx # 初始化博客</span><br><span class="line"></span><br><span class="line">hexo n &quot;blog name&quot; # 新建文章，会在&#x2F;source&#x2F;_posts&#x2F;这个路径下生成一个新的md，因此文章内容按照Markdwon格式来写就行了</span><br><span class="line">hexo g &#x3D;&#x3D; hexo generate # 生成</span><br><span class="line">hexo s &#x3D;&#x3D; hexo server # 启动服务预览</span><br><span class="line">hexo d &#x3D;&#x3D; hexo deploy # 部署</span><br><span class="line"></span><br><span class="line">hexo server # Hexo会监视文件变动并自动更新，无须重启服务器</span><br><span class="line">hexo server -s # 静态模式</span><br><span class="line">hexo server -p 5000 # 更改端口</span><br><span class="line">hexo server -i 192.168.1.1 # 自定义 IP</span><br><span class="line">hexo clean # 清除缓存，若是网页正常情况下可以忽略这条命令</span><br></pre></td></tr></table></figure></p>
<h2 id="更改网站的主题"><a href="#更改网站的主题" class="headerlink" title="更改网站的主题"></a>更改网站的主题</h2><p>&emsp;&emsp;我用的是<a href="https://github.com/Shen-Yu/hexo-theme-ayer" target="_blank" rel="noopener">Ayer</a>主题，如果想要试试其他主题的话，可以到Hexo官网的<a href="https://hexo.io/themes/" target="_blank" rel="noopener">主题专栏</a>中找找有没有喜欢的。找到自己新颖的主题后，在终端用<strong>Git</strong>克隆对应主题到blog目录下即可，这里以Ayer主题为例，在终端输入：<code>git clone https://github.com/Shen-Yu/hexo-theme-ayer.git themes/ayer</code>。<br>&emsp;&emsp;耐心等待主题安装完成后，在终端中输入(路径为blog根目录)：<code>vi _config.yml</code>。在该配置文件中找到<strong>theme</strong>这个配置项，将其更改为<code>theme: ayer</code>就行了。</p>
<center>
    <img style="border-radius: 0.3125em; margin-top: 10px; width: 600px; height: 400px; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src="https://blog-1253514421.cos.ap-shanghai.myqcloud.com/4A0F3F66-62FA-4A8D-8714-7D0E86390D29.png">
    <br>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">新更换的主题</div>
</center>

<p>&emsp;&emsp;这里对于主题的配置不多介绍，每个主题都有对应的文档可以查看，而且挺多都是有中文文档的，因此绝对比我讲的更加清晰。</p>
<h2 id="推送网站"><a href="#推送网站" class="headerlink" title="推送网站"></a>推送网站</h2><p>&emsp;&emsp;<a href="https://hexo.io/zh-cn/docs/one-command-deployment" target="_blank" rel="noopener">Hexo官方</a>给出了多种推送方式，这里我们用<strong>Git</strong>来推送网站。首先，我们安装下<strong>Git</strong>的部署插件，在终端中输入命令(<strong>blog根目录下</strong>)：<code>npm install hexo-deployer-git --save</code> 然后，我们在终端中输入：<code>vi _config.yml</code>，在该文件中找到<strong>deploy</strong>这一项，完成以下配置：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">    type: git</span><br><span class="line">    repo: 仓库的完整路径</span><br><span class="line">    branch: master</span><br></pre></td></tr></table></figure></p>
<center>
    <img style="border-radius: 0.3125em; margin-top: 10px; width: 600px; height: 200px; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src="https://blog-1253514421.cos.ap-shanghai.myqcloud.com/8EBEB1C6-61E5-4B7B-9CB9-9F55EA364450.png">
    <br>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">需修改的配置</div>
</center>

<p>&emsp;&emsp;完成以上配置后，保存退出配置文档，在终端依次输入下面这三条命令后，等待命令运行结束，并观察终端是否显示上传成功的信息。如上传成功后，打开浏览器，在地址栏输入你的放置个人网站的仓库路径，即<a href="http://xxx.github.io" target="_blank" rel="noopener">xxx.github.io</a> （这里的xxx是你的仓库名）。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo clean </span><br><span class="line">hexo g </span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure></p>
<center>
    <img style="border-radius: 0.3125em; margin-top: 10px; width: 700px; height: 400px; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src="https://blog-1253514421.cos.ap-shanghai.myqcloud.com/D17E2895-E74B-4BF7-9A8F-0AE4EF3C991D.png ">
    <br>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">访问博客主页</div>
</center>

<p>&emsp;&emsp;至此，我们的博客算是正式创建好了，之后就可以根据自己的需求进行个性化更改了。</p>
<h2 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h2><p>&emsp;&emsp;博客的域名是可以自定义的，只要你有一个属于自己的域名，那么你就可以将GitHub提供的这个链接替换成自己的专属域名。如果需要的话，可以利用搜索引擎查找下，这类资料网上还是挺多的。</p>
<p><a href= "https://github.com/zioang/zioang.github.io" target="_blank" style="margin-top: 20px; text-decoration: none;"><br>    <img src="https://blog-1253514421.cos.ap-shanghai.myqcloud.com/github.png" style="width: 20px; height: 20px; margin-right: 6px; float: left"><br>    <p style=" line-height: 20px; font-size: 16px; color: black; font-family: Hiragino Sans GB, WenQuanYi Micro Hei;">项目地址</p>
</a></p>
]]></content>
      <categories>
        <category>日常折腾</category>
      </categories>
      <tags>
        <tag>macOS</tag>
        <tag>博客相关</tag>
      </tags>
  </entry>
</search>
