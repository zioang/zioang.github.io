<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Java虚拟机 —— 垃圾回收算法（二）</title>
    <url>/2020/07/16/jvm-2/</url>
    <content><![CDATA[<h3 id="什么是垃圾回收"><a href="#什么是垃圾回收" class="headerlink" title="什么是垃圾回收"></a>什么是垃圾回收</h3><p>&emsp;&emsp;垃圾回收( Garbage Collection, 简称 GC ) ，是指一种自动的存储器管理机制。当某个程序占用的一部分内存空间不再被这个程序访问时，这个程序会借助垃圾回收算法向操作系统归还这部分内存空间。垃圾回收器可以减轻程序员的负担，也减少程序中的错误。(<a href="https://zh.wikipedia.org/wiki/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6_(%E8%A8%88%E7%AE%97%E6%A9%9F%E7%A7%91%E5%AD%B8" target="_blank" rel="noopener">摘自维基百科</a>))</p>
<h3 id="哪些垃圾需要被回收"><a href="#哪些垃圾需要被回收" class="headerlink" title="哪些垃圾需要被回收"></a>哪些垃圾需要被回收</h3><p>&emsp;&emsp;在上一篇中介绍了 JVM 内存运行时区域的各部分，其中程序计数器、 Java 栈和本地方法栈三个区域随线程而生，随线程而灭，因此这几个区域的内存分配和回收都具备确定性。但 Java 堆和方法区则不一样，一个接口中的多个实现累、一个方法中的多个分支，它们所需要的内存可能不一样，我们只有在程序处于运行期间时才能直到需要创建哪些对象，因此这部分的内存分配和回收都是动态的，而 GC 主要负责回收的就是这部分内存。</p>
<a id="more"></a>
<h3 id="垃圾回收基本算法"><a href="#垃圾回收基本算法" class="headerlink" title="垃圾回收基本算法"></a>垃圾回收基本算法</h3><h4 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h4><p>&emsp;&emsp;引用计数法 ( Reference Counting ) 的实现十分简单：对于一个对象 A ，给其添加一个引用计数器，只要任何一个对象引用了 A ，则 A 的引用计数器就加 1 ；当引用失效时，引用计数器就减 1 。只要当对象 A 的引用计数器的值为 0 时，则对象 A 就不可能再被使用，这时便需要回收它。</p>
<p>&emsp;&emsp;引用计数算法  是最经典也是最古老的一种垃圾回收算法，在很多著名的应用案例中，都有着它的身影。但是，JVM 却没有选用它来管理内存，因为它存在以下两个严重的问题:</p>
<ul>
<li>无法处理对象的循环调用，如下图所示。</li>
</ul>
<center>
    <img style="border-radius: 0.3125em; margin-top: 10px; width: 95%; height: 350px; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src="https://blog-1253514421.cos.ap-shanghai.myqcloud.com/20200722142127.png">
    <br>
</center>

<ul>
<li>引用计数器要求在每次调用产生或消除的时候，伴随一个加法或减法操作，对系统性能会有一定的影响。</li>
</ul>
<p>&emsp;&emsp;以下面的代码为例，首先初始化对象 objA 与对象 objB ，然后另它们互相引用，除此之外这两个对象再无任何引用。按照算法的定义，因为它们的引用计数器都不为 0 ，所以引用计数器算法便无法通知 GC 回收它们。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 引用计数算法</span></span><br><span class="line"><span class="comment"> * VM Args: -XX:+PrintGCDetails</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReferenceCountingGC</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ReferenceCountingGCTest gcTest = <span class="keyword">new</span> ReferenceCountingGCTest();</span><br><span class="line">        gcTest.testGC();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ReferenceCountingGCTest</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Object instance = <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testGC</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">            ReferenceCountingGCTest objA = <span class="keyword">new</span> ReferenceCountingGCTest();</span><br><span class="line">            ReferenceCountingGCTest objB = <span class="keyword">new</span> ReferenceCountingGCTest();</span><br><span class="line"></span><br><span class="line">            objA.instance = objB;</span><br><span class="line">            objB.instance = objA;</span><br><span class="line"></span><br><span class="line">            objA = <span class="keyword">null</span>;</span><br><span class="line">            objB = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">            System.gc();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;事实上，结果并没如我们所愿。当我们运行该程序后，根据控制台打印出的 JVM 内存信息( 信息见下表 )，可以发现 <strong>Java 堆</strong>发生了内存释放，由 <strong>416K-&gt;289K(125952K)</strong>。从而，我们可以得知 JVM 并不是通过引用计数算法来判断对象是否存活的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[Full GC [PSYoungGen: <span class="number">416</span>K-&gt;<span class="number">0</span>K(<span class="number">38912</span>K)] [ParOldGen: <span class="number">0</span>K-&gt;<span class="number">289</span>K(<span class="number">87040</span>K)] <span class="number">416</span>K-&gt;<span class="number">289</span>K(<span class="number">125952</span>K) [PSPermGen: <span class="number">2622</span>K-&gt;<span class="number">2621</span>K(<span class="number">21504</span>K)], <span class="number">0.0081770</span> secs] [Times: user=<span class="number">0.02</span> sys=<span class="number">0.00</span>, real=<span class="number">0.01</span> secs] </span><br><span class="line">Heap</span><br><span class="line"> PSYoungGen      total <span class="number">38912</span>K, used <span class="number">1013</span>K [<span class="number">0x00000007d5500000</span>, <span class="number">0x00000007d8000000</span>, <span class="number">0x0000000800000000</span>)</span><br><span class="line">  eden space <span class="number">33792</span>K, <span class="number">3</span>% used [<span class="number">0x00000007d5500000</span>,<span class="number">0x00000007d55fd7d0</span>,<span class="number">0x00000007d7600000</span>)</span><br><span class="line">  from space <span class="number">5120</span>K, <span class="number">0</span>% used [<span class="number">0x00000007d7600000</span>,<span class="number">0x00000007d7600000</span>,<span class="number">0x00000007d7b00000</span>)</span><br><span class="line">  to   space <span class="number">5120</span>K, <span class="number">0</span>% used [<span class="number">0x00000007d7b00000</span>,<span class="number">0x00000007d7b00000</span>,<span class="number">0x00000007d8000000</span>)</span><br><span class="line"> ParOldGen       total <span class="number">87040</span>K, used <span class="number">289</span>K [<span class="number">0x0000000780000000</span>, <span class="number">0x0000000785500000</span>, <span class="number">0x00000007d5500000</span>)</span><br><span class="line">  object space <span class="number">87040</span>K, <span class="number">0</span>% used [<span class="number">0x0000000780000000</span>,<span class="number">0x0000000780048430</span>,<span class="number">0x0000000785500000</span>)</span><br><span class="line"> PSPermGen       total <span class="number">21504</span>K, used <span class="number">2628</span>K [<span class="number">0x000000077ae00000</span>, <span class="number">0x000000077c300000</span>, <span class="number">0x0000000780000000</span>)</span><br><span class="line">  object space <span class="number">21504</span>K, <span class="number">12</span>% used [<span class="number">0x000000077ae00000</span>,<span class="number">0x000000077b091220</span>,<span class="number">0x000000077c300000</span>)</span><br></pre></td></tr></table></figure>
<h4 id="根搜索算法"><a href="#根搜索算法" class="headerlink" title="根搜索算法"></a>根搜索算法</h4><p>&emsp;&emsp;根搜索算法( GC Roots Tracing ) 在主流的程序语言中，都是用其来判定对象是否存活的。它的数据结构与图论中的 <strong>树</strong> 相似，基本思路是通过一系列的名为 <strong>“ GC Roots ”</strong> 的对象(根)作为起始点，从这些根节点开始向下寻找子节点，搜索所走过的路径称为<strong>引用链 ( Reference Chain )</strong> ，当从 GC Roots 到某个对象<strong>不可达</strong>时 ( 两者之间没有引用链 ) ，则证明此对象是不可用的。</p>
<center>
    <img style="border-radius: 0.3125em; margin-top: 10px; width: 95%; height: 350px; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src="https://blog-1253514421.cos.ap-shanghai.myqcloud.com/20200722150950.png">
    <br>
</center>

<p>&emsp;&emsp;如上图所示，obj 1 ~ 6 都是可从 GC Roots 搜索到的，而 obj 7、obj 8 虽然互相有关联，但是它们却无法到达 GC Roots，所以它们将会被判定为可回收的对象。</p>
<h5 id="GC-Roots-对象"><a href="#GC-Roots-对象" class="headerlink" title="GC Roots 对象"></a>GC Roots 对象</h5><ul>
<li><p>虚拟机栈 ( 栈帧中的本地变量表 ) 中的引用的对象</p>
</li>
<li><p>方法区中的类静态属性引用的对象</p>
</li>
<li><p>方法区中的常量引用的对象</p>
</li>
<li><p>本地方法栈中 Native 方法的引用的对象</p>
</li>
</ul>
<h4 id="标记清除算法"><a href="#标记清除算法" class="headerlink" title="标记清除算法"></a>标记清除算法</h4><p>&emsp;&emsp;标记清除算法 ( Mark - Sweep ) 是现代垃圾回收算法的思想基础，如它的名字一样，算法分为“标记”和“清除”两个阶段：</p>
<ul>
<li><p>标记阶段：通过根节点搜索所有从根节点开始的可达对象，并将其标记为<strong>存活状态</strong>；而未被搜索到的对象便是未被引用的垃圾对象，将其标记为<strong>可回收状态</strong>。</p>
</li>
<li><p>清除阶段：清除所有被标记为<strong>可回收状态</strong>的对象。</p>
</li>
</ul>
<center>
    <img style="border-radius: 0.3125em; margin-top: 10px; width: 95%; height: 500px; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src="https://blog-1253514421.cos.ap-shanghai.myqcloud.com/20200724101043.png">
    <br>
</center>

<p>&emsp;&emsp;上图是使用标记清除法对一块连续的内存空间进行回收。首先，从 root 出发，所有的可达的对象均被标记为存活状态 ( 箭头代表对象可达 )，而不可达的对象均未垃圾对象，为可回收状态。在标记操作完成后，系统将会对回收所有“可回收状态”下的空间。</p>
<p>&emsp;&emsp;虽然标记清除法能很好的回收垃圾对象，但是其还是存在两个问题：</p>
<ul>
<li><p>效率问题：标记和清除过程的效率都不高，其处理时间和存活对象数与对象总数的总和相关。</p>
</li>
<li><p>空间问题：从上图我们可以看出，使用标记清除法后会产生大量不连续的内存碎片。由于空间碎片过多，当程序在以后的运行过程中需要分配较大对象时，可能无法找到足够的连续内存而不得不提前触发另一次 GC。</p>
</li>
</ul>
<h4 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h4><p>&emsp;&emsp;为了解决上述的效率问题，一种称为复制算法 ( Copying ) 的收集算法应运而生。其核心思想是：将一块可用的内存空间，划分为等大的两块。每次只使用其中的一块，在进行回收操作时，将正在使用的内存块中的存活对象，复制到未使用的内存块中，之后清除正在使用的内存块中的所有对象，最后交换两个内存块的角色，完成垃圾回收。</p>
<center>
    <img style="border-radius: 0.3125em; margin-top: 10px; width: 95%; height: 500px; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src="https://blog-1253514421.cos.ap-shanghai.myqcloud.com/20200724104418.png">
    <br>
</center>

<p>&emsp;&emsp;复制算法的过程如上图所示，其回收效率高，且确保了回收后的空间没有碎片。但是由于其代价是将系统内存折半，性价比太低，因此只是单纯使用在了<strong>新生代串行垃圾回收器</strong>中。</p>
<p>&emsp;&emsp;IBM 的专门研究表明，新生代中的对象 98% 是朝生夕死的，所以不需要按 1 : 1 的比例来划分内存空间，而是将内存划分为 2 块：新生代占 1 / 3，老年代占 2 / 3。其中，新生代又可继续细分为两块：Eden 内存空间占新生代的 8 / 10，而两块 Survivor 内存空间( Form 区和 To 区 ) 占 2 / 10。</p>
<center>
    <img style="border-radius: 0.3125em; margin-top: 10px; width: 95%; height: 500px; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src="https://blog-1253514421.cos.ap-shanghai.myqcloud.com/20200724135210.png">
    <br>
</center>

<p>&emsp;&emsp;在进行垃圾回收时，Eden 区的存活对象会被复制到空闲中的 Survivor 区 ( 上图中的 To 区，实际过程中 From 区和 To 区交换使用 ) ，From 区中的年轻对象也会被复制到 To 区，而大文件或者老年对象是直接进入 Tenured 区。当 To 区( 指代未被使用的 Survivor 区 )已满，则对象也会直接进入 Tenured 区。复制完毕后，Eden 区和 From 区 ( 指代正在被使用的 Survivor 区 ) 中的对象便可以全部被清除回收，此时 From 区和 To 区的角色进行交换。</p>
<p>&emsp;&emsp;复制算法既保证了空间的连续性，又避免了大量的内存空间浪费，一定程度上解决了标记清除算法的空间问题，但是<strong>无法适用于存活对象多的情况</strong>。</p>
<h4 id="标记压缩算法"><a href="#标记压缩算法" class="headerlink" title="标记压缩算法"></a>标记压缩算法</h4><p>&emsp;&emsp;由于复制算法在对象存活率较高时就要执行较多的复制操作，效率将会变低。而在<strong>老年代</strong>，大部分对象都是存活对象的情况十分常见 ( 特别是老年代中的所有对象都处于存活状态的这种极端情况 )，复制算法的成本将会很高 ( 极端情况下可能会浪费 50% 的内存空间 )。</p>
<p>&emsp;&emsp;根据上述老年代的特点，标记压缩算法( Mark - Compact ) 便正式出现在了 GC 的舞台上。该算法的思路是建立在标记清除算法的基础上，其对标记清楚法进行了一些优化：将所有存活对象都向内存空间中的一端移动( 如下图蓝色箭头所示 )，然后清理边界外的所有空间。这种算法，既避免了碎片的产生，又不需要划分出两块等大的内存空间，性价比优于前两种算法。</p>
<center>
    <img style="border-radius: 0.3125em; margin-top: 10px; width: 95%; height: 500px; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src="https://blog-1253514421.cos.ap-shanghai.myqcloud.com/20200724143632.png">
    <br>
</center>

<h3 id="垃圾回收的算法思想"><a href="#垃圾回收的算法思想" class="headerlink" title="垃圾回收的算法思想"></a>垃圾回收的算法思想</h3><h4 id="分代算法"><a href="#分代算法" class="headerlink" title="分代算法"></a>分代算法</h4><p>&emsp;&emsp;对于前面介绍的标记清除算法、复制算法和标记压缩算法中，没有一种算法可以完全代替其他算法，它们都有自己的优缺点，因此我们需<strong>根据 GC 对象的特性，来选择合适的算法</strong>。</p>
<p>&emsp;&emsp;分代算法 ( Generational Collecting ) 就是基于上述思想，根据每块内存空间的特点使用不同的回收算法，以提高 GC 的效率，该思想被现有虚拟机广泛使用。</p>
<p>&emsp;&emsp;在 Java 堆中，由于新生代中的对象大多都是朝生夕死，大约 90% 的新建对象都很快被回收，因此适合使用复制算法；而由于老年区中的对象都是经过多次 GC 后仍存活的，并可能持续到未来 ( 可将其理解成常驻内存 ) ，因此不适用于需要经常复制对象的复制算法，而是使用标记清除算法或标记压缩算法。</p>
<p>&emsp;&emsp;通常<strong>新生代回收的频率高、耗时短，老年代回收的频率低、耗时长</strong>，当存在老年代的对象引用了新生代的对象时，那标记存活对象的时候，需要扫描老年代中的所有对象，此时可能需要耗费大量的时间。而为了解决这个问题，HotSpot 给出了一种解决方案，即：一种名为 <strong>“卡表 ( Card Table ) ”</strong> 的技术。它将整个 Java 堆划分为一个个大小字节相等的卡，每个卡都可以用来表示老年代的某一区域中的所有对象是否有对新生代对象的引用，而卡表便是由这些卡组成的一个比特位集合。</p>
<center>
    <img style="border-radius: 0.3125em; margin-top: 10px; width: 95%; height: 400px; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src="https://blog-1253514421.cos.ap-shanghai.myqcloud.com/20200724154754.png">
    <br>
</center>

<p>&emsp;&emsp;如上图所示，在新生代 GC 时，便不需要花费大量时间扫描所有的老年代对象来确定引用关系，可以先扫描卡表，只有当卡表的标记为 1 时，才需要扫描给定区域的老年对象，而卡表的标记为 0 的老年代对象肯定不含用新生代对象的引用。使用这种方式，可以大大加快新生代的回收速度。</p>
<h4 id="分区算法"><a href="#分区算法" class="headerlink" title="分区算法"></a>分区算法</h4><p>&emsp;&emsp;众所周知，在相同条件下，堆空间越大，一次 GC 所需的时间一般就越长，从而产生的<a href="#GC-的停顿现象">停顿</a>也越长。而分区算法 ( Region ) 根据对象的声明周期长短分为两个状态，并将整个内存空间划分成连续的不同的小区间，每个区间都可独立使用、回收。</p>
<center>
    <img style="border-radius: 0.3125em; margin-top: 10px; width: 95%; height: 400px; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src="https://blog-1253514421.cos.ap-shanghai.myqcloud.com/20200724162655.png">
    <br>
</center>

<p>&emsp;&emsp;为了更好地控制 GC 产生的停顿时间，将一块大的内存区域分隔成多个小块 ( 如上图所示 ) ，然后根据目标的停顿时间，每次合理地回收若干个小区间，而不是回收整个堆空间，从而减少一次 GC 所产生的停顿。</p>
<h3 id="不可达的对象的处理方法"><a href="#不可达的对象的处理方法" class="headerlink" title="不可达的对象的处理方法"></a>不可达的对象的处理方法</h3><p>&emsp;&emsp;对于不可达的对象，并不是马上就会被回收，由存活到死亡需要经过两次<strong>标记</strong>过程 ( 三种状态：可达的、可逃脱的、不可达的 ) ：</p>
<ul>
<li><p>第一次：如果从所有的根节点开始都无法访问到某个对象，说明该对象已经不再被使用，那它将会被第一次标记并进行一次筛选。筛选的条件是此对象是否有必要执行 <strong>finalize()</strong> 方法( <strong>任一对象只能被其调用一次</strong> )，判定的标准是：对象是否复写了 finalize() 方法或者虚拟机是否调用了 finalize() 方法，若有则不执行。</p>
</li>
<li><p>第二次：对象被执行 finalize() 方法后，被放置在一个名为 <strong>F-Queue</strong> 的对象( 即将被回收的对象集合 )中。如果 finalize() 方法执行过程中，<strong>其只要与引用链上的任意对象建立关联</strong>，便可存活下去；反之则被标记，将在下一次 GC 时被回收。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对象在第二次标记前逃脱回收，但只能逃脱一次</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalizeEscapeGC</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> FinalizeEscapeGC SAVE_HOOK = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">super</span>.finalize();</span><br><span class="line">        System.out.println(<span class="string">"finalize method executed!"</span>);</span><br><span class="line">        FinalizeEscapeGC.SAVE_HOOK = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">finalizeEscapeGCTest</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        SAVE_HOOK = <span class="keyword">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">        <span class="comment">// 等待 Finalizer 方法指执行</span></span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        <span class="keyword">if</span>(SAVE_HOOK != <span class="keyword">null</span>)</span><br><span class="line">            System.out.println(<span class="string">"alive"</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            System.out.println(<span class="string">"dead"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        SAVE_HOOK =  <span class="keyword">new</span> FinalizeEscapeGC();</span><br><span class="line">        <span class="comment">// 对象第一次被标记，逃脱回收</span></span><br><span class="line">        finalizeEscapeGCTest();</span><br><span class="line">        <span class="comment">// 第二次标记，逃脱失败，因为 finalize() 方法只能被调用一次</span></span><br><span class="line">        finalizeEscapeGCTest();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果:</span><br><span class="line">finalize method executed!</span><br><span class="line">alive</span><br><span class="line">dead</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;上述代码中，调用了两次 <strong>finalizeEscapeGCTest()</strong> 方法，但得到的结果却不一样。根据运行结果，我们可以得知：SAVE_HOOK 对象的 finalize() 方法确实被 GC 收集器触发过，并且在被 GC 前成功逃脱了。在第一次调用该方法时，对象逃脱成功；而在第二次调用该方法时，对象逃脱失败。其原因便是： <strong>finalize() 方法只能被系统自动调用一次</strong>，如果对象面临下一次回收，它的 finalize() 方法不会再被执行，因此第二次逃脱失败。</p>
<h3 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h3><h4 id="强引用-Strong-Reference"><a href="#强引用-Strong-Reference" class="headerlink" title="强引用( Strong Reference )"></a>强引用( Strong Reference )</h4><p>&emsp;&emsp;最常使用的 <strong>new</strong> 对象，类似 <code>Object obj = new Object()</code>。只要强引用还在，那么该对象就不会被回收，其具备以下特点：</p>
<ul>
<li><p>强引用可以直接访问目标对象。</p>
</li>
<li><p>强引用所指向的对象在任何时候都不会被系统回收，虚拟机宁愿抛出 OOM 异常，也不会回收强引用的对象。</p>
</li>
<li><p>强应用可能导致内存泄漏。</p>
</li>
</ul>
<h4 id="软引用-Soft-Reference"><a href="#软引用-Soft-Reference" class="headerlink" title="软引用( Soft Reference )"></a>软引用( Soft Reference )</h4><p>&emsp;&emsp;有用但非必须的对象，如果一个对象只持有软引用，那么当堆空间不足时就会被回收。软引用可用 <code>java.lang.ref.SoftReference</code> 类实现，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.ref.ReferenceQueue;</span><br><span class="line"><span class="keyword">import</span> java.lang.ref.SoftReference;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过引用队列，跟踪软引用对象的回收情况</span></span><br><span class="line"><span class="comment"> * VM Args: -Xmx10m -XX:+PrintGCDetails</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SoftRefQ</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * User对象类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(<span class="keyword">int</span> id, String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.id = id;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"User&#123;"</span> +</span><br><span class="line">                    <span class="string">"id="</span> + id +</span><br><span class="line">                    <span class="string">", name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                    <span class="string">'&#125;'</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// User类型的引用队列</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ReferenceQueue&lt;User&gt; softRefQueue = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 跟踪引用队列，并打印对象的回收情况</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CheckRefQueue</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (softRefQueue != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    UserSoftReference obj = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        obj = (UserSoftReference) softRefQueue.remove();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (obj != <span class="keyword">null</span>)</span><br><span class="line">                        System.out.println(<span class="string">"user id "</span> + obj.uid + <span class="string">" is delete"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自定义的软引用类</span></span><br><span class="line"><span class="comment">     * 扩展软引用的目的是记录 User.id，</span></span><br><span class="line"><span class="comment">     * 后续在引用队列中可通过这个 uid 来知道哪个 User 实例被回收</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">UserSoftReference</span> <span class="keyword">extends</span> <span class="title">SoftReference</span>&lt;<span class="title">User</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> uid;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">UserSoftReference</span><span class="params">(User referent, ReferenceQueue&lt;? <span class="keyword">super</span> User&gt; q)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(referent, q);</span><br><span class="line">            uid = referent.id;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        Thread t = <span class="keyword">new</span> CheckRefQueue();</span><br><span class="line">        <span class="comment">// 设置为守护线程</span></span><br><span class="line">        t.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">        t.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建强引用</span></span><br><span class="line">        User u = <span class="keyword">new</span> User(<span class="number">1</span>, <span class="string">"geym"</span>);</span><br><span class="line">        softRefQueue = <span class="keyword">new</span> ReferenceQueue&lt;User&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建软引用</span></span><br><span class="line">        UserSoftReference userSoftReference = <span class="keyword">new</span> UserSoftReference(u, softRefQueue);</span><br><span class="line">        <span class="comment">// 去强引用</span></span><br><span class="line">        u = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第一次从软引用获得对象</span></span><br><span class="line">        System.out.println(userSoftReference.get());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第二次从软引用获取对象</span></span><br><span class="line">        <span class="comment">// 内存足够，对象不会被回收</span></span><br><span class="line">        System.gc();</span><br><span class="line">        System.out.println(<span class="string">"After GC:"</span>);</span><br><span class="line">        System.out.println(userSoftReference.get());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建大数组，耗尽内存</span></span><br><span class="line">        System.out.println(<span class="string">"try to create byte array and GC"</span>);</span><br><span class="line">        <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">980</span> * <span class="number">7</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第三次从软引用获取对象</span></span><br><span class="line">        <span class="comment">// 内存不够，对象被回收</span></span><br><span class="line">        System.gc();</span><br><span class="line">        System.out.println(userSoftReference.get());</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">控制台输出：</span><br><span class="line"></span><br><span class="line">User&#123;id=<span class="number">1</span>, name=<span class="string">'geym'</span>&#125;</span><br><span class="line"></span><br><span class="line">[GC (System.gc()) [PSYoungGen: <span class="number">675</span>K-&gt;<span class="number">448</span>K(<span class="number">2560</span>K)] <span class="number">675</span>K-&gt;<span class="number">456</span>K(<span class="number">9728</span>K), <span class="number">0.0012302</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line">[<span class="function">Full <span class="title">GC</span> <span class="params">(System.gc()</span>) [PSYoungGen: 448K-&gt;0<span class="title">K</span><span class="params">(<span class="number">2560</span>K)</span>] [ParOldGen: 8K-&gt;313<span class="title">K</span><span class="params">(<span class="number">7168</span>K)</span>] 456K-&gt;313<span class="title">K</span><span class="params">(<span class="number">9728</span>K)</span>, [Metaspace: 2652K-&gt;2652<span class="title">K</span><span class="params">(<span class="number">1056768</span>K)</span>], 0.0075992 secs] [Times: user</span>=<span class="number">0.01</span> sys=<span class="number">0.00</span>, real=<span class="number">0.01</span> secs] </span><br><span class="line"></span><br><span class="line">After GC:</span><br><span class="line">User&#123;id=<span class="number">1</span>, name=<span class="string">'geym'</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> to create <span class="keyword">byte</span> array and GC</span><br><span class="line"></span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: <span class="number">40</span>K-&gt;<span class="number">64</span>K(<span class="number">2560</span>K)] <span class="number">354</span>K-&gt;<span class="number">377</span>K(<span class="number">9728</span>K), <span class="number">0.0012228</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: <span class="number">64</span>K-&gt;<span class="number">32</span>K(<span class="number">2560</span>K)] <span class="number">377</span>K-&gt;<span class="number">345</span>K(<span class="number">9728</span>K), <span class="number">0.0011872</span> secs] [Times: user=<span class="number">0.01</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line">[<span class="function">Full <span class="title">GC</span> <span class="params">(Allocation Failure)</span> [PSYoungGen: 32K-&gt;0<span class="title">K</span><span class="params">(<span class="number">2560</span>K)</span>] [ParOldGen: 313K-&gt;308<span class="title">K</span><span class="params">(<span class="number">5632</span>K)</span>] 345K-&gt;308<span class="title">K</span><span class="params">(<span class="number">8192</span>K)</span>, [Metaspace: 2652K-&gt;2652<span class="title">K</span><span class="params">(<span class="number">1056768</span>K)</span>], 0.0044651 secs] [Times: user</span>=<span class="number">0.01</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: <span class="number">0</span>K-&gt;<span class="number">0</span>K(<span class="number">2560</span>K)] <span class="number">308</span>K-&gt;<span class="number">308</span>K(<span class="number">9728</span>K), <span class="number">0.0009767</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.01</span> secs] </span><br><span class="line">[<span class="function">Full <span class="title">GC</span> <span class="params">(Allocation Failure)</span> [PSYoungGen: 0K-&gt;0<span class="title">K</span><span class="params">(<span class="number">2560</span>K)</span>] [ParOldGen: 308K-&gt;296<span class="title">K</span><span class="params">(<span class="number">6656</span>K)</span>] 308K-&gt;296<span class="title">K</span><span class="params">(<span class="number">9216</span>K)</span>, [Metaspace: 2652K-&gt;2652<span class="title">K</span><span class="params">(<span class="number">1056768</span>K)</span>], 0.0032058 secs] [Times: user</span>=<span class="number">0.01</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line"></span><br><span class="line">user id <span class="number">1</span> is delete</span><br><span class="line"></span><br><span class="line">[GC (System.gc()) [PSYoungGen: <span class="number">81</span>K-&gt;<span class="number">64</span>K(<span class="number">2560</span>K)] <span class="number">7238</span>K-&gt;<span class="number">7220</span>K(<span class="number">9728</span>K), <span class="number">0.0008571</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line">[<span class="function">Full <span class="title">GC</span> <span class="params">(System.gc()</span>) [PSYoungGen: 64K-&gt;0<span class="title">K</span><span class="params">(<span class="number">2560</span>K)</span>] [ParOldGen: 7156K-&gt;7156<span class="title">K</span><span class="params">(<span class="number">7168</span>K)</span>] 7220K-&gt;7156<span class="title">K</span><span class="params">(<span class="number">9728</span>K)</span>, [Metaspace: 2652K-&gt;2652<span class="title">K</span><span class="params">(<span class="number">1056768</span>K)</span>], 0.0044073 secs] [Times: user</span>=<span class="number">0.01</span> sys=<span class="number">0.00</span>, real=<span class="number">0.01</span> secs] </span><br><span class="line"></span><br><span class="line"><span class="keyword">null</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;从控制台输出的结果可以发现，当对象建立软应用后，即使该对象不再被使用，也不会立马被回收，而是内存不够时，才会将其回收。</p>
<h4 id="弱引用-Weak-Reference"><a href="#弱引用-Weak-Reference" class="headerlink" title="弱引用( Weak Reference )"></a>弱引用( Weak Reference )</h4><p>&emsp;&emsp;有用但非必须的对象，强度比软引用更弱一些。当系统进行 GC 时，只要发现弱引用的存在，变回将对象立即回收。但是，实际上弱引用对象可以存在较长的时间，因为 GC 的线程优先级通常很低，因此不一定能很快地发现软引用对象。弱引用同样可用 <code>java.lang.ref.WeakReference</code> 类实现，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.ref.ReferenceQueue;</span><br><span class="line"><span class="keyword">import</span> java.lang.ref.SoftReference;</span><br><span class="line"><span class="keyword">import</span> java.lang.ref.WeakReference;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过引用队列，跟踪弱引用对象的回收情况</span></span><br><span class="line"><span class="comment"> * VM Args: -Xmx10m -XX:+PrintGCDetails</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeakRefQ</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * User对象类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(<span class="keyword">int</span> id, String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.id = id;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"User&#123;"</span> +</span><br><span class="line">                    <span class="string">"id="</span> + id +</span><br><span class="line">                    <span class="string">", name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                    <span class="string">'&#125;'</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// User类型的引用队列</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ReferenceQueue&lt;WeakRefQ.User&gt; weakRefQueue = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 跟踪引用队列，并打印对象的回收情况</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CheckRefQueue</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (weakRefQueue != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    WeakRefQ.UserWeakReference obj = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        obj = (WeakRefQ.UserWeakReference) weakRefQueue.remove();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (obj != <span class="keyword">null</span>)</span><br><span class="line">                        System.out.println(<span class="string">"user id "</span> + obj.uid + <span class="string">" is delete"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自定义的软引用类</span></span><br><span class="line"><span class="comment">     * 扩展软引用的目的是记录 User.id，</span></span><br><span class="line"><span class="comment">     * 后续在引用队列中可通过这个 uid 来知道哪个 User 实例被回收</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">UserWeakReference</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">WeakRefQ</span>.<span class="title">User</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> uid;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">UserWeakReference</span><span class="params">(WeakRefQ.User referent, ReferenceQueue&lt;? <span class="keyword">super</span> WeakRefQ.User&gt; q)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(referent, q);</span><br><span class="line">            uid = referent.id;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        Thread t = <span class="keyword">new</span> SoftRefQ.CheckRefQueue();</span><br><span class="line">        <span class="comment">// 设置为守护线程</span></span><br><span class="line">        t.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">        t.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建强引用</span></span><br><span class="line">        WeakRefQ.User u = <span class="keyword">new</span> WeakRefQ.User(<span class="number">1</span>, <span class="string">"geym"</span>);</span><br><span class="line">        weakRefQueue = <span class="keyword">new</span> ReferenceQueue&lt;WeakRefQ.User&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建软引用</span></span><br><span class="line">        WeakRefQ.UserWeakReference userWeakReference = <span class="keyword">new</span> WeakRefQ.UserWeakReference(u, weakRefQueue);</span><br><span class="line">        <span class="comment">// 去强引用</span></span><br><span class="line">        u = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第一次从软引用获得对象</span></span><br><span class="line">        System.out.println(userWeakReference.get());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第二次从软引用获取对象</span></span><br><span class="line">        <span class="comment">// 内存足够，对象不会被回收</span></span><br><span class="line">        System.gc();</span><br><span class="line">        System.out.println(<span class="string">"After GC:"</span>);</span><br><span class="line">        System.out.println(userWeakReference.get());</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">控制台输出：</span><br><span class="line"></span><br><span class="line">User&#123;id=<span class="number">1</span>, name=<span class="string">'geym'</span>&#125;</span><br><span class="line"></span><br><span class="line">[GC (System.gc()) [PSYoungGen: <span class="number">716</span>K-&gt;<span class="number">496</span>K(<span class="number">2560</span>K)] <span class="number">716</span>K-&gt;<span class="number">512</span>K(<span class="number">9728</span>K), <span class="number">0.0012134</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line">[<span class="function">Full <span class="title">GC</span> <span class="params">(System.gc()</span>) [PSYoungGen: 496K-&gt;0<span class="title">K</span><span class="params">(<span class="number">2560</span>K)</span>] [ParOldGen: 16K-&gt;314<span class="title">K</span><span class="params">(<span class="number">7168</span>K)</span>] 512K-&gt;314<span class="title">K</span><span class="params">(<span class="number">9728</span>K)</span>, [Metaspace: 2655K-&gt;2655<span class="title">K</span><span class="params">(<span class="number">1056768</span>K)</span>], 0.0033517 secs] [Times: user</span>=<span class="number">0.02</span> sys=<span class="number">0.00</span>, real=<span class="number">0.01</span> secs] </span><br><span class="line"></span><br><span class="line">After GC:</span><br><span class="line"><span class="keyword">null</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;实现代码与软引用的类似，都是通过引用队列来跟踪对象的回收情况。从控制台的输出结果我们可以发现，当对象是软引用对象时，在 GC 之后便被立马回收了。</p>
<h4 id="虚引用-Phantom-Reference，又称幽灵引用或幻影引用"><a href="#虚引用-Phantom-Reference，又称幽灵引用或幻影引用" class="headerlink" title="虚引用( Phantom Reference，又称幽灵引用或幻影引用 )"></a>虚引用( Phantom Reference，又称幽灵引用或幻影引用 )</h4><p>&emsp;&emsp;最弱的一种引用，不会给对象的生存时间构成影响，也无法取得一个对象实例，唯一的目的是在这个对象被 GC 时能收到一个系统通知。下面，通过一段代码来实现虚引用跟踪一个可复活对象的回收：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.ref.PhantomReference;</span><br><span class="line"><span class="keyword">import</span> java.lang.ref.ReferenceQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 虚引用跟踪一个可复活对象的回收</span></span><br><span class="line"><span class="comment"> * VM Args: -Xmx10m -XX:+PrintGCDetails</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PhantomRefQ</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> PhantomRefQ obj;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> ReferenceQueue&lt;PhantomRefQ&gt; phantomQueue = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 跟踪引用队列，并打印对象的回收情况</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CheckRefQueue</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(phantomQueue != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    PhantomReference&lt;PhantomRefQ&gt; objt = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">try</span>&#123;</span><br><span class="line">                        objt = (PhantomReference&lt;PhantomRefQ&gt;) phantomQueue.remove();</span><br><span class="line">                    &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(objt != <span class="keyword">null</span>)</span><br><span class="line">                        System.out.println(<span class="string">"obj is delete by GC"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对象逃脱 GC</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">super</span>.finalize();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"PhantomRefQ finalize called"</span>);</span><br><span class="line"></span><br><span class="line">        obj = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        Thread t = <span class="keyword">new</span> PhantomRefQ.CheckRefQueue();</span><br><span class="line">        <span class="comment">// 设置为守护线程</span></span><br><span class="line">        t.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">        t.start();</span><br><span class="line"></span><br><span class="line">        phantomQueue = <span class="keyword">new</span> ReferenceQueue&lt;PhantomRefQ&gt;();</span><br><span class="line">        <span class="comment">// 创建强引用</span></span><br><span class="line">        obj = <span class="keyword">new</span> PhantomRefQ();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建虚引用</span></span><br><span class="line">        <span class="comment">// 用于跟踪对象引用情况</span></span><br><span class="line">        PhantomReference&lt;PhantomRefQ&gt; phantomRef = <span class="keyword">new</span> PhantomReference&lt;PhantomRefQ&gt;(obj, phantomQueue);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第一回收，去强引用，并触发 GC</span></span><br><span class="line">        System.out.println(<span class="string">"第一次 GC"</span>);</span><br><span class="line"></span><br><span class="line">        obj = <span class="keyword">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(obj == <span class="keyword">null</span>)</span><br><span class="line">            System.out.println(<span class="string">"obj is null"</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            System.out.println(<span class="string">"obj is live"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第二次回收，去强引用，并触发 GC</span></span><br><span class="line">        System.out.println(<span class="string">"第二次 GC"</span>);</span><br><span class="line"></span><br><span class="line">        obj = <span class="keyword">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(obj == <span class="keyword">null</span>)</span><br><span class="line">            System.out.println(<span class="string">"obj is null"</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            System.out.println(<span class="string">"obj is live"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">控制台输出：</span><br><span class="line"></span><br><span class="line">第一次 GC</span><br><span class="line"></span><br><span class="line">[GC (System.gc()) [PSYoungGen: <span class="number">634</span>K-&gt;<span class="number">480</span>K(<span class="number">2560</span>K)] <span class="number">634</span>K-&gt;<span class="number">488</span>K(<span class="number">9728</span>K), <span class="number">0.0012460</span> secs] [Times: user=<span class="number">0.01</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line">[<span class="function">Full <span class="title">GC</span> <span class="params">(System.gc()</span>) [PSYoungGen: 480K-&gt;0<span class="title">K</span><span class="params">(<span class="number">2560</span>K)</span>] [ParOldGen: 8K-&gt;312<span class="title">K</span><span class="params">(<span class="number">7168</span>K)</span>] 488K-&gt;312<span class="title">K</span><span class="params">(<span class="number">9728</span>K)</span>, [Metaspace: 2644K-&gt;2644<span class="title">K</span><span class="params">(<span class="number">1056768</span>K)</span>], 0.0038555 secs] [Times: user</span>=<span class="number">0.01</span> sys=<span class="number">0.00</span>, real=<span class="number">0.01</span> secs]</span><br><span class="line"></span><br><span class="line">PhantomRefQ finalize called</span><br><span class="line">obj is live</span><br><span class="line"></span><br><span class="line">第二次 GC</span><br><span class="line"></span><br><span class="line">[GC (System.gc()) [PSYoungGen: <span class="number">123</span>K-&gt;<span class="number">96</span>K(<span class="number">2560</span>K)] <span class="number">435</span>K-&gt;<span class="number">408</span>K(<span class="number">9728</span>K), <span class="number">0.0008649</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line">[<span class="function">Full <span class="title">GC</span> <span class="params">(System.gc()</span>) [PSYoungGen: 96K-&gt;0<span class="title">K</span><span class="params">(<span class="number">2560</span>K)</span>] [ParOldGen: 312K-&gt;307<span class="title">K</span><span class="params">(<span class="number">7168</span>K)</span>] 408K-&gt;307<span class="title">K</span><span class="params">(<span class="number">9728</span>K)</span>, [Metaspace: 2645K-&gt;2645<span class="title">K</span><span class="params">(<span class="number">1056768</span>K)</span>], 0.0041441 secs] [Times: user</span>=<span class="number">0.02</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line"></span><br><span class="line">obj is delete by GC</span><br><span class="line">obj is <span class="keyword">null</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;上述代码主要是利用了 finalize() 方法，可让对象逃脱一次 GC ，并使用虚引用和引用队列来跟踪回收。根据控制台的输出信息，我们可以发现 <code>obj</code> 在第一次 GC 时，因为调用了 finalize() 方法而逃脱了一次回收，但是在第二次 GC 后，根据引用队列捕获到的信息，可以发现 <code>obj</code> 被回收了。</p>
<h3 id="GC-的停顿现象"><a href="#GC-的停顿现象" class="headerlink" title="GC 的停顿现象"></a>GC 的停顿现象</h3><p>&emsp;&emsp;GC 的停顿现象又称 <strong>“ Stop - The - World ”</strong> ( 接下来的篇章都以 STW 代指 )，目的是挂起当前处于执行状态的所有线程，令系统状态在某一瞬间保持一致，只有这样系统才不会有新的垃圾产生，有益于垃圾收集器标记垃圾对象。当停顿产生时，整个程序都将会处于无响应的状态。下面通过一个示例演示 GC 的停顿现象，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 演示 GC 的停顿现象</span></span><br><span class="line"><span class="comment"> * VM Args: -XX:+PrintGCApplicationStoppedTime -XX:+PrintGCDetails</span></span><br><span class="line"><span class="comment"> * PrintGCApplicationStoppedTime: 打印GC停顿耗时</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StopTheWolrd</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Collection&lt;Object&gt; leak = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                leak.add(<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">1024</span>]);</span><br><span class="line">            &#125; <span class="keyword">catch</span>(OutOfMemoryError e) &#123;</span><br><span class="line">                leak.clear();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;上述代码中，通过不断消耗内存资源来引发 GC，通过以下两个参数<code>-XX:+PrintGCApplicationStoppedTime -XX:+PrintGCDetails</code>来观察停顿现象，控制台输出如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[GC (Allocation Failure) </span><br><span class="line">    [PSYoungGen: <span class="number">464087</span>K-&gt;<span class="number">232451</span>K(<span class="number">465920</span>K)] </span><br><span class="line">    <span class="number">929014</span>K-&gt;<span class="number">928806</span>K(<span class="number">1369600</span>K), <span class="number">0.0452468</span> secs] </span><br><span class="line">[Times: user=<span class="number">0.33</span> sys=<span class="number">0.00</span>, real=<span class="number">0.04</span> secs] </span><br><span class="line">[<span class="function">Full <span class="title">GC</span> <span class="params">(Ergonomics)</span> </span></span><br><span class="line"><span class="function">    [PSYoungGen: 232451K-&gt;25600<span class="title">K</span><span class="params">(<span class="number">465920</span>K)</span>] </span></span><br><span class="line"><span class="function">    [ParOldGen: 696354K-&gt;902760<span class="title">K</span><span class="params">(<span class="number">1398272</span>K)</span>] </span></span><br><span class="line"><span class="function">    928806K-&gt;928360<span class="title">K</span><span class="params">(<span class="number">1864192</span>K)</span>,</span></span><br><span class="line"><span class="function">    [Metaspace: 3150K-&gt;3150<span class="title">K</span><span class="params">(<span class="number">1056768</span>K)</span>], </span></span><br><span class="line"><span class="function">    0.1219848 secs] </span></span><br><span class="line"><span class="function">[Times: user</span>=<span class="number">0.83</span> sys=<span class="number">0.00</span>, real=<span class="number">0.13</span> secs] </span><br><span class="line"></span><br><span class="line">Total time <span class="keyword">for</span> which application threads were stopped: <span class="number">0.1674905</span> seconds, </span><br><span class="line">Stopping threads took: <span class="number">0.0000132</span> seconds</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;从打印信息中，我们可以得知：应用程序线程被迫停止了 <strong>167 毫秒</strong>以等待进行垃圾回收，期间等待所有应用程序线程到达<strong>安全点</strong>所花的时间为 <strong>13 微秒</strong>。</p>
]]></content>
      <categories>
        <category>JVM</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Java虚拟机 —— 运行时数据区的JVM规范（一）</title>
    <url>/2020/07/13/jvm-1/</url>
    <content><![CDATA[<h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>&emsp;&emsp;本系列笔记主要参考了 “<strong>深入理解Java虚拟机 - JVM高级特性与最佳实践</strong>”、“<strong>实战Java虚拟机 - JVM故障诊断与性能优化(第二版)</strong>” 和相关博客。因此，若无特别说明jdk的版本，那么所使用的 jdk 版本为 1.7。</p>
<h3 id="运行时数据区的JVM规范"><a href="#运行时数据区的JVM规范" class="headerlink" title="运行时数据区的JVM规范"></a>运行时数据区的JVM规范</h3><p>&emsp;&emsp;首先，我们需要事先明白 <strong>JVM 规范</strong>和 <strong>HotSpot 实现</strong>是两种不同的东西。可以把JVM规范理解成接口，然后不同的虚拟机有不同的实现方案，如方法区：HotSpot 在JDK 1.7 及以前版本，用了永久代；而 JDK 1.8 及以后版本用了元数据区。</p>
<p>&emsp;&emsp;在官方给出的 <a href="https://docs.oracle.com/javase/specs/jvms/se8/jvms8.pdf" target="_blank" rel="noopener">java SE 虚拟机标准</a> 中( 见下图 )，我们可以发现，运行时数据区可被分为 6 块：<strong>程序计数器、堆、Java 虚拟机栈、本地方法栈、运行时常量池和方法区</strong>。</p>
<center>
    <img style="border-radius: 0.3125em; margin-top: 10px; width: 400px; height: 200px; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src="https://blog-1253514421.cos.ap-shanghai.myqcloud.com/20200721145042.png">
    <br>
</center>

<h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><p>&emsp;&emsp;程序技术器( Program Counter Register ) 是一块较小的内存空间，每个线程都有自己独立的程序计数器。其中，各线程之间的计数器互不影响，独立存储，因此我们将这类区域称为“<strong>线程私有</strong>”的内存。它的作用可以看作是当前线程所执行的字节码的行号指示器。如果当前线程执行的是 Java 方法，则程序计数器中是当前执行虚所机字节码指令的地址，而如果正在执行是 Native 方法，这个计数器的值就是 undefined。</p>
<a id="more"></a>
<h3 id="Java-堆"><a href="#Java-堆" class="headerlink" title="Java 堆"></a>Java 堆</h3><p>&emsp;&emsp;Java 堆是被所有线程所共享的一块区域( Java 虚拟机所管理的内存中最大的一块 )，几乎所有的对象实例都存放在堆中( <strong>由于栈上分配、标量替换优化技术的出现，导致没那么的绝对</strong> )，且Java 堆是完全 <strong>自动化管理</strong> 的，通过垃圾回收机制，垃圾对象会被自动清理，而不需要人为释放。</p>
<p>&emsp;&emsp;根据垃圾回收机制的不同，Java 堆有可能会拥有不同的结构。其中，最为常见的一种是将其分为 <strong>新生代和老年代</strong>。其中，新生代存放新生对象或年龄不大的对象，老年代则存放老年对象。如下表所示，新生代可分为 Eden、S0、S1，其中 S0 和 S1 被称为幸存者区 ( Survivor Space )， 它们分别又被称为 From 和 To 区域，它们是两块大小相等、可以互换的内存空间。</p>
<center>
    <img style="border-radius: 0.3125em; margin-top: 10px; width: 600px; height: 300px; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src="https://blog-1253514421.cos.ap-shanghai.myqcloud.com/20200716093220.png">
    <br>
</center>

<p>&emsp;&emsp;在绝大多数情况下，对象首先是在 Eden 区创建，否则，也就是少数的情况下，其是在 Tenured 区创建。幸存者区域是新生代与老年代的缓冲区域，当触发 <strong>Minor GC ( 新生代回收 )</strong> 后将<strong>仍然存活</strong>的对象从 Eden 区中移动到 S0 中去，这样 Eden 就被清空可以分配给新的对象。而当 <strong>再一次</strong> 触发 Minor GC 后，<strong>S0 和 Eden</strong> 中存活的对象被移动到 S1 中，S0 即被清空。</p>
<p>&emsp;&emsp;在同一时刻, 只有 Eden 和一个 Survivor Space 同时被操作。所以 S0 与 S1 两块区同时会至少有一个为空闲的。当每次对象从 Eden 复制到 Survivor Space 或者在 Survivor Space 之间复制时，<strong>程序计数器</strong> 会自动增加其值。默认情况下如果复制发生超过 16 次，JVM 就会停止复制并把他们移到 Tenured 区。</p>
<p>&emsp;&emsp;Tenured 区用于存放程序中经过几次垃圾回收后还存活的对象，例如缓存的对象等。当 Tenured 区内存空间不够时，JVM 会在 Tenured 区进行一次 Major GC ( 老年代回收 )，Major GC 的速度一般会比 Minor GC 慢10倍以上。</p>
<h4 id="Java堆溢出"><a href="#Java堆溢出" class="headerlink" title="Java堆溢出"></a>Java堆溢出</h4><p>&emsp;&emsp;Java堆内存的溢出异常是实际应用中最常见的 <strong>内存溢出异常</strong>。出现Java堆内存溢出时，异常堆栈信息 <code>java.lang.OutOfMemoryError</code> 会跟着进一步提示 <code>Java heap space</code>。这里，我们首先限制Java堆的大小为20M，避免堆的自动扩展。然后通过不断创建对象，来模拟在对象数量达到最大堆的容量限制后，产生内存溢出异常，代码见下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Java堆溢出测试</span></span><br><span class="line"><span class="comment"> * VM Args: -Xms20m -Xmx20m</span></span><br><span class="line"><span class="comment"> * -Xms: 堆的最小值</span></span><br><span class="line"><span class="comment"> * -Xmx: 堆的最大值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapOOM</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">OOMObject</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[ ] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        List&lt;OOMObject&gt; list = <span class="keyword">new</span> ArrayList&lt;OOMObject&gt;( );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> OOMObject( ));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;使用 <strong>-Xms20m -Xmx20m</strong> 执行以上代码后，部分输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Exception in thread <span class="string">"main"</span> java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">	at java.util.Arrays.copyOf(Arrays.java:<span class="number">3210</span>)</span><br><span class="line">	at java.util.Arrays.copyOf(Arrays.java:<span class="number">3181</span>)</span><br></pre></td></tr></table></figure>
<h3 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h3><p>&emsp;&emsp;Java虚拟机栈 ( Java Virtual Machine Stacks，下面简称 Java栈) 是一块<strong>线程私有的内存空间</strong>，其和线程执行密切相关。线程执行的基本行为是方法调用，而每次方法调用的数据都是通过Java栈来传递的。每个方法被执行的时候，都会同时创建一个 <strong>栈帧( Stack Frame, Java栈的基本单位 )</strong> 用于存储局部变量表、操作数栈、帧数据区(包含动态联接、方法出口、异常处理表等数据)等信息。因此，每一个方法被调用直至执行完成的过程，就对应着一个栈帧在Java栈中从入栈到出栈的过程。</p>
<p>&emsp;&emsp;栈帧在Java栈中的出入栈过程，与数据结构中的栈操作过程类似，如下图。每一次方法的<strong>调用</strong>，都会有一个对应的栈帧被<strong>压入</strong>Java栈。当没到该方法<strong>调用结束</strong>时，栈帧继续在栈中等待，直到轮到该方法返回时，栈帧从Java栈中被<strong>弹出</strong>。Java方法有两站返回方法的方式，一种是正常的方法返回，即return指令；另外一种则是异常抛出。而不管是哪一种方式，都会导致栈帧被弹出。</p>
<center>
    <img style="border-radius: 0.3125em; margin-top: 10px; width: 700px; height: 400px; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src="https://blog-1253514421.cos.ap-shanghai.myqcloud.com/20200714170138.png">
    <br>
</center>

<h4 id="Java栈溢出"><a href="#Java栈溢出" class="headerlink" title="Java栈溢出"></a>Java栈溢出</h4><p>&emsp;&emsp;如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出 <strong>StackOverflowError</strong> 异常。为此，Java虚拟机提供了参数 <strong>-Xss</strong> 来指定线程的最大空间，这个参数也直接决定了方法调用的 <strong>最大深度</strong>。于是，我们可以通过该参数来模拟下Java栈溢出。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackSOF</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> stackLength = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stackLeak</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ++stackLength;</span><br><span class="line">        stackLeak();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable</span>&#123;</span><br><span class="line"></span><br><span class="line">        StackSOF ssof = <span class="keyword">new</span> StackSOF();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ssof.stackLeak();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Throwable e)&#123;</span><br><span class="line">            System.out.println(<span class="string">"stack length: "</span> + ssof.stackLength);</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;由于该代码中未给出递归方法的出口，因此当递归达到了允许调用的最大深度后，程序将抛出错误，并打印最大的调用深度。</p>
<p>&emsp;&emsp;使用 <strong>-Xss160k</strong> 执行以上代码后，部分结果如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">stack length: <span class="number">776</span></span><br><span class="line">Exception in thread <span class="string">"main"</span> java.lang.StackOverflowError</span><br><span class="line">	at oom.StackSOF.stackLeak(StackSOF.java:<span class="number">13</span>)</span><br><span class="line">	at oom.StackSOF.stackLeak(StackSOF.java:<span class="number">14</span>)</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;而使用 <strong>-Xss320k</strong> 执行以上代码后，部分结果如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">stack length: <span class="number">2638</span></span><br><span class="line">Exception in thread <span class="string">"main"</span> java.lang.StackOverflowError</span><br><span class="line">	at oom.StackSOF.stackLeak(StackSOF.java:<span class="number">13</span>)</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;可以看到，随着 -Xss 值的增大，方法可以获得更深的调用层次。因此，我们可以得到一个信息：方法嵌套调用的层次很大程度上由栈的大小决定，即栈越大，方法可嵌套调用的次数就越多。 </p>
<h4 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h4><p>&emsp;&emsp;局部变量表的最小单位称为 <strong>“变量槽(Slot)”</strong>。它可用来保存方法的参数和局部变量，并且所需要的内存空间在编译期间完成分配，因此在方法运行期间是不会改变局部变量表的大小的。其可以是下表中的任意类型。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">数据类型</th>
<th style="text-align:center">占用的Slot个数</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">boolean</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">byte</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">char</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">short</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">int</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">float</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">long</td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:center">double</td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:center">reference</td>
<td style="text-align:center">1 or 2</td>
</tr>
<tr>
<td style="text-align:center">returnAddress</td>
<td style="text-align:center">1</td>
</tr>
</tbody>
</table>
</div>
<p>&emsp;&emsp;表中，long 和 double 类型都是 64 位数据类型，需占用 2 个连续的 Slot。 reference 类型 不等同于对象本身，它可能是一个指向对象起始地址的引用指针，也可能指向一个代表对象的句柄或者其他与此对象相关的位置，因此它会占用 1 或 2 个 Slot。而 returnAddress 类型指向了一条字节码指令的地址。</p>
<p>&emsp;&emsp;由于局部变量表存储在栈帧中，因此，如果方法所拥有的 <strong>参数和局部变量</strong> 较多，会使局部变量表 <strong>膨胀</strong>，从而每一次方法调用就会 <strong>占用更多的栈空间</strong>，最终导致方法的嵌套调用次数 <strong>减少</strong>。下面的代码将展示在含参数和局部变量，及不含参数的情况下对方法调用层次的影响。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * VM Args: -Xss160K</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackDeep</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> stackLength = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">recursion</span><span class="params">(<span class="keyword">long</span> a, <span class="keyword">long</span> b, <span class="keyword">long</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> d = <span class="number">4</span>, e = <span class="number">5</span>, f = <span class="number">6</span>;</span><br><span class="line">        ++stackLength;</span><br><span class="line">        recursion(a, b, c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">recursion</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ++stackLength;</span><br><span class="line">        recursion();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            recursion(<span class="number">1L</span>, <span class="number">2L</span>, <span class="number">3L</span>);</span><br><span class="line">            <span class="comment">// recursion();</span></span><br><span class="line">        &#125;<span class="keyword">catch</span> (Throwable e)&#123;</span><br><span class="line">            System.out.println(<span class="string">"stack length: "</span> + stackLength);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;如上代码所示，当我们调用含参数及局部变量的方法时，它所能调用的层次如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">stack length: <span class="number">388</span></span><br><span class="line">java.lang.StackOverflowError</span><br><span class="line">	at oom.StackDeep.recursion(StackDeep.java:<span class="number">12</span>)</span><br><span class="line">	at oom.StackDeep.recursion(StackDeep.java:<span class="number">14</span>)</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;而当我们调用不含参数及局部变量的方法时，它所能调用的层次如下表所示。通过对比两者的差异，可以看到，在相同栈容量下，局部变量或参数少的方法，可以达到更深层次的方法调用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">stack length: <span class="number">854</span></span><br><span class="line">java.lang.StackOverflowError</span><br><span class="line">	at oom.StackDeep.recursion(StackDeep.java:<span class="number">18</span>)</span><br><span class="line">	at oom.StackDeep.recursion(StackDeep.java:<span class="number">19</span>)</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;为了尽可能节省栈帧的空间，局部变量表实现了 <strong>Slot 复用</strong> 的功能(如下代码所示，通过 <strong>-XX:+PrintGC</strong> 来查看垃圾回收前后堆的大小)。由于方法中定义的变量，其作用域并不一定会覆盖整个方法。如果当前的字节码 PC 计数器的值已经超出了某个变量的作用域，那么这个变量所对应的 Slot 就可以被其他变量所使用，而与此会影响系统垃圾回收的行为。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 变量槽复用</span></span><br><span class="line"><span class="comment"> * VM Args: -XX:+PrintGC</span></span><br><span class="line"><span class="comment"> * PrintGC: 打印GC信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LocalVarGC</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">localVarGC1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] a = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">6</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">localVarGC2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] a = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">6</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">localVarGC3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] a = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">6</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        LocalVarGC gc = <span class="keyword">new</span> LocalVarGC();</span><br><span class="line">        gc.localVarGC1();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;在 localVarGC1() 中，在申请空间后，立即进行垃圾回收，由于 byte 数组被变量 a 引用，因此无法回收这块空间，GC 打印如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[Full GC <span class="number">6592</span>K-&gt;<span class="number">6431</span>K(<span class="number">125952</span>K), <span class="number">0.0095330</span> secs]</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;在 localVarGC2() 中，虽然 a 在垃圾回收前就被失效了，但是变量 a 在局部变量表中依然存在，即变量 a 与 byte 数组之间仍存在关联，因此无法回收这块空间，GC 打印如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[Full GC <span class="number">6560</span>K-&gt;<span class="number">6431</span>K(<span class="number">125952</span>K), <span class="number">0.0072220</span> secs]</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;在 localVarGC3() 中，在垃圾回收前，先使变量 a 失效，然后声明了一个变量 b，这样便使变量 b 复用了变量 a 的 Slot，即复用打断了变量 a 与 byte 数组之间的关联，因此垃圾回收器顺利回收了 byte 数组。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[Full GC <span class="number">7475</span>K-&gt;<span class="number">440</span>K(<span class="number">125952</span>K), <span class="number">0.0075550</span> secs]</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;从 localVarGC3() 的打印信息中可以看到，堆空间从 7475K 变回 440K，释放了约 6MB 空间，进而可以推断出 byte 数组被回收释放。</p>
<h4 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h4><p>&emsp;&emsp;每一个独立的栈帧中，除了包含局部变量表外，还包括操作数栈，它主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间。如下代码，完成了变量 a 与变量 b 相加后加值赋予给变量 c 的功能。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleOperandStack</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">10</span>, b = <span class="number">20</span>;</span><br><span class="line">        <span class="keyword">int</span> c = a + b;</span><br><span class="line">        System.out.println(c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;编译上述代码后，通过 <strong>javap</strong> 指令来执行对应文件，可得到下表中的信息。</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">4</span>, args_size=<span class="number">1</span></span><br><span class="line">         // 将 <span class="number">10</span> 压入操作数栈</span><br><span class="line">         <span class="number">0</span>: bipush        <span class="number">10</span></span><br><span class="line">         // 将操作数栈中的值出栈并保存到局部变量表中的第 <span class="number">1</span> 个 Slot 位置</span><br><span class="line">         <span class="number">2</span>: istore_1</span><br><span class="line">         // 将 <span class="number">20</span> 压入操作数栈</span><br><span class="line">         <span class="number">3</span>: bipush        <span class="number">20</span></span><br><span class="line">         // 将操作数栈中的值出栈并保存到局部变量表中的第 <span class="number">2</span> 个 Slot 位置</span><br><span class="line">         <span class="number">5</span>: istore_2</span><br><span class="line">         // 复制局部变量表中第 <span class="number">1</span> 个 Slot 位置的值，并压入到操作数栈</span><br><span class="line">         <span class="number">6</span>: iload_1</span><br><span class="line">         // 同上</span><br><span class="line">         <span class="number">7</span>: iload_2</span><br><span class="line">         // iadd 的指令是用来将两个栈顶的值依次出栈，</span><br><span class="line">         // 对两个值做整形加法，将结果重新入栈</span><br><span class="line">         <span class="number">8</span>: iadd</span><br><span class="line">         // 将操作数栈中的值出栈并保存到局部变量表中的第 <span class="number">3</span> 个 Slot 位置</span><br><span class="line">         <span class="number">9</span>: istore_3</span><br><span class="line">        // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">        // 调用输出方法</span><br><span class="line">        <span class="number">10</span>: getstatic     #<span class="number">2</span></span><br><span class="line">        // 复制局部变量表中第 <span class="number">3</span> 个 Slot 位置的值，并压入到操作数栈              </span><br><span class="line">        <span class="number">13</span>: iload_3</span><br><span class="line">        // Method java/io/PrintStream.println:(I)V</span><br><span class="line">        //打印操作数栈的栈顶的值</span><br><span class="line">        <span class="number">14</span>: invokevirtual #<span class="number">3</span>                 </span><br><span class="line">        <span class="number">17</span>: <span class="keyword">return</span></span><br><span class="line">      // 局部变量表</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0      18     0  args   [Ljava/lang/String;</span><br><span class="line">            <span class="number">3</span>      <span class="number">15</span>     <span class="number">1</span>     <span class="keyword">a</span>   I</span><br><span class="line">            <span class="number">6</span>      <span class="number">12</span>     <span class="number">2</span>     <span class="keyword">b</span>   I</span><br><span class="line">           <span class="number">10</span>       <span class="number">8</span>     <span class="number">3</span>     <span class="keyword">c</span>   I</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;由上表内容可知，操作数栈的深度为 2，局部变量表的空间为 4。具体的流程，已在上述代码中添加了相应的注释，如需更深入的了解，可以参考这篇 <a href="https://zhuanlan.zhihu.com/p/45354152" target="_blank" rel="noopener">博客</a>。下图中，也稍微描述了下代码执行过程中，操作数栈中的变化和局部变量表中的值。</p>
<center>
    <img style="border-radius: 0.3125em; margin-top: 10px; width: 600px; height: 500px; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src="https://blog-1253514421.cos.ap-shanghai.myqcloud.com/20200715155836.png">
    <br>
</center>

<h4 id="帧数据区"><a href="#帧数据区" class="headerlink" title="帧数据区"></a>帧数据区</h4><p>&emsp;&emsp;帧数据区是用来保存一些可支持常量池解析、正常方法返回和异常处理等的数据。大部分Java字节码指令需要进行常量池访问，在帧数据区中保存这访问常量池的指针，方便程序访问常量池。<br>&emsp;&emsp;此外，当方法返回或出现异常时，虚拟机必须恢复调用者方法的栈帧，并让方法继续执行。对于异常处理，可以参考如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleOperandStack</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">10</span>, b = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> c = a / b;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;当程序执行到 <strong>a / b</strong> 这一步时，因为 “0” 不能作为除数，因此程序将抛出错误。可以通过 <code>javap -c Main xxx.class</code> 这段指令来查看编译信息。</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">public static void main(java.lang.String[]);</span><br><span class="line">   Code:</span><br><span class="line">      <span class="number">0</span>: bipush        <span class="number">10</span></span><br><span class="line">      <span class="number">2</span>: istore_1</span><br><span class="line">      <span class="number">3</span>: iconst_0</span><br><span class="line">      <span class="number">4</span>: istore_2</span><br><span class="line">      <span class="number">5</span>: iload_1</span><br><span class="line">      <span class="number">6</span>: iload_2</span><br><span class="line">      <span class="number">7</span>: idiv</span><br><span class="line">      <span class="number">8</span>: istore_3</span><br><span class="line">      <span class="number">9</span>: <span class="keyword">goto</span>          <span class="number">17</span></span><br><span class="line">     <span class="number">12</span>: astore_3</span><br><span class="line">     <span class="number">13</span>: aload_3</span><br><span class="line">     // Method java/lang/Exception.printStackTrace:()V</span><br><span class="line">     <span class="number">14</span>: invokevirtual #<span class="number">3</span>                  </span><br><span class="line">     <span class="number">17</span>: <span class="keyword">return</span></span><br><span class="line">   Exception table:</span><br><span class="line">      from    <span class="keyword">to</span>  target <span class="built_in">type</span></span><br><span class="line">          <span class="number">5</span>     <span class="number">9</span>    <span class="number">12</span>   Class java/lang/Exception</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;通过观察上表，我们可以得出：程序在字节码偏移量 5 ~ 9 字节可能抛出异常，如果遇到异常，则跳转到 字节码偏移量 12 处继续执行。当方法抛出异常时，虚拟机就会查找类似的异常表来处理，如果无法在异常表中找到合适的处理方法，则会结束当前的方法调用，返回调用方法，并在调用方法中抛出相同的异常，并查找调用方法的异常表进行处理。</p>
<h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>&emsp;&emsp;本地方法栈 ( Native Method Stacks ) 与 Java 虚拟机栈非常类似，在 JVM 规范层面：最大的不同在于 Java 虚拟机栈为 Java 方法( 字节码 )服务，而本地方法栈为虚拟机所使用到的 Native 方法服务。作为对 Java 虚拟机的重要扩展，JVM 允许 Java 直接调用本地方法，通常使用 C 语言编写；而在 HotSpot 实现层面，本地方法栈和 Java 虚拟机栈被合二为一。</p>
<h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p>&emsp;&emsp;和 Java 堆一样，方法区 ( Method Area ) 也是一块<strong>所有线程共享</strong>的内存区域，它用于存放 <strong>Class</strong> 的相关信息，如类名、访问修饰符、方法描述、字段描述、常量池等。方法区的大小决定了系统可以保存的类的个数，如果程序定义了太多的类，导致方法区溢出，虚拟机同样会抛出内存溢出异常。</p>
<h4 id="方法区溢出-jdk1-7版本"><a href="#方法区溢出-jdk1-7版本" class="headerlink" title="方法区溢出( jdk1.7版本 )"></a>方法区溢出( jdk1.7版本 )</h4><p>&emsp;&emsp;在 jdk 1.6、jdk 1.7 版本中，方法区又可称为永久区 ( Prem )。永久区可以使用参数-XX:PermSize 和 -XX:MaxPermSize 来设置，默认情况下，最大永久区为64MB。为了确保不发生永久区内存溢出，我们需要设置一个合理的永久区大小，保证程序的正常运行。下面，我们通过一段代码，来模拟永久区内存溢出异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过不停的加载class来模拟方法区溢出(jdk1.8版本被弃用, 程序运行将不会报错, 因为永久代已被删除)</span></span><br><span class="line"><span class="comment"> * VM Args: -XX:+PrintGCDetails -XX:PermSize=5m -XX:MaxPermSize=5m</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaMethodAreaOOM</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">                enhancer.setSuperclass(JavaMethodAreaOOM<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">                enhancer.setUseCache(<span class="keyword">false</span>);</span><br><span class="line">                enhancer.setCallback(<span class="keyword">new</span> MethodInterceptor() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> methodProxy.invokeSuper(o, objects);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">                enhancer.create();</span><br><span class="line">                ++i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"total create count: "</span> + i);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;代码中，指定了初始永久区为 5MB，最大永久区为 5MB。因此当5MB内存空间耗尽时，系统将抛出内存溢出异常。然后，我们借用 <strong>Cglib 库</strong>来反复动态生成一个类，以及一个类的实例对象，直到抛出方法区的内存溢出异常。执行程序后，部分输入如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[Full GC </span><br><span class="line">    [PSYoungGen: <span class="number">0</span>K-&gt;<span class="number">0</span>K(<span class="number">41984</span>K)] </span><br><span class="line">    [ParOldGen: <span class="number">895</span>K-&gt;<span class="number">894</span>K(<span class="number">286720</span>K)] <span class="number">895</span>K-&gt;<span class="number">894</span>K(<span class="number">328704</span>K) </span><br><span class="line">    [PSPermGen: <span class="number">4095</span>K-&gt;<span class="number">4089</span>K(<span class="number">4096</span>K)], <span class="number">0.0082080</span> secs</span><br><span class="line">] </span><br><span class="line">[Times: user=<span class="number">0.03</span> sys=<span class="number">0.00</span>, real=<span class="number">0.01</span> secs] </span><br><span class="line"></span><br><span class="line">total create count: <span class="number">59</span></span><br><span class="line"></span><br><span class="line">Heap</span><br><span class="line"> PSYoungGen      total <span class="number">54784</span>K, used <span class="number">1075</span>K [<span class="number">0x00000007d5500000</span>, <span class="number">0x00000007d9000000</span>, <span class="number">0x0000000800000000</span>)</span><br><span class="line">  eden space <span class="number">53760</span>K, <span class="number">2</span>% used [<span class="number">0x00000007d5500000</span>,<span class="number">0x00000007d560cd20</span>,<span class="number">0x00000007d8980000</span>)</span><br><span class="line">  from space <span class="number">1024</span>K, <span class="number">0</span>% used [<span class="number">0x00000007d8980000</span>,<span class="number">0x00000007d8980000</span>,<span class="number">0x00000007d8a80000</span>)</span><br><span class="line">  to   space <span class="number">1024</span>K, <span class="number">0</span>% used [<span class="number">0x00000007d8f00000</span>,<span class="number">0x00000007d8f00000</span>,<span class="number">0x00000007d9000000</span>)</span><br><span class="line"> ParOldGen       total <span class="number">1397760</span>K, used <span class="number">673</span>K [<span class="number">0x0000000780000000</span>, <span class="number">0x00000007d5500000</span>, <span class="number">0x00000007d5500000</span>)</span><br><span class="line">  object space <span class="number">1397760</span>K, <span class="number">0</span>% used [<span class="number">0x0000000780000000</span>,<span class="number">0x00000007800a87c0</span>,<span class="number">0x00000007d5500000</span>)</span><br><span class="line"> PSPermGen       total <span class="number">4096</span>K, used <span class="number">4095</span>K [<span class="number">0x000000077fc00000</span>, <span class="number">0x0000000780000000</span>, <span class="number">0x0000000780000000</span>)</span><br><span class="line">  object space <span class="number">4096</span>K, <span class="number">99</span>% used [<span class="number">0x000000077fc00000</span>,<span class="number">0x000000077fffffe8</span>,<span class="number">0x0000000780000000</span>)</span><br><span class="line"></span><br><span class="line">Caused by: java.lang.OutOfMemoryError: PermGen space</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;可以看到，当生成 59 个类后，程序便抛出了内存溢出异常( <strong>OutOfMemoryError</strong> )。此时，永久区( <strong>PSPermGen</strong> )的利用率达到了 99%，5MB 的内存空间已经几乎被使用光了。</p>
<h4 id="方法区溢出-jdk1-8版本"><a href="#方法区溢出-jdk1-8版本" class="headerlink" title="方法区溢出 ( jdk1.8版本 )"></a>方法区溢出 ( jdk1.8版本 )</h4><p>&emsp;&emsp;因为永久区在 <strong>jdk 1.8</strong> 版本便被删除了，取而代之的是元数据区，而元数据区的大小我们可以用参数 <code>MetaspaceSize 和 MaxMetaspaceSize</code> 来指定。这是一块堆外的内存，因此，如果不指定大小，默认情况下虚拟机会耗尽所有可用的系统内存。下面，我们利用上面的代码，只需更改下 jdk 版本和虚拟机参数，即可得到以下部分输出：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">[<span class="function">Full <span class="title">GC</span> <span class="params">(Last ditch collection)</span> </span></span><br><span class="line"><span class="function">    [PSYoungGen: 0K-&gt;0<span class="title">K</span><span class="params">(<span class="number">152576</span>K)</span>] </span></span><br><span class="line"><span class="function">    [ParOldGen: 1471K-&gt;1471<span class="title">K</span><span class="params">(<span class="number">308224</span>K)</span>] 1471K-&gt;1471<span class="title">K</span><span class="params">(<span class="number">460800</span>K)</span>, </span></span><br><span class="line"><span class="function">    [Metaspace: 8674K-&gt;8674<span class="title">K</span><span class="params">(<span class="number">1058816</span>K)</span>], 0.0058397 secs</span></span><br><span class="line"><span class="function">] </span></span><br><span class="line"><span class="function">[Times: user</span>=<span class="number">0.02</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line"></span><br><span class="line">total create count: <span class="number">369</span></span><br><span class="line"></span><br><span class="line">Heap</span><br><span class="line"> PSYoungGen      total <span class="number">182784</span>K, used <span class="number">3805</span>K [<span class="number">0x00000007d5380000</span>, <span class="number">0x00000007e0900000</span>, <span class="number">0x00000007ffe00000</span>)</span><br><span class="line">  eden space <span class="number">180736</span>K, <span class="number">2</span>% used [<span class="number">0x00000007d5380000</span>,<span class="number">0x00000007d57376d8</span>,<span class="number">0x00000007e0400000</span>)</span><br><span class="line">  from space <span class="number">2048</span>K, <span class="number">0</span>% used [<span class="number">0x00000007e0700000</span>,<span class="number">0x00000007e0700000</span>,<span class="number">0x00000007e0900000</span>)</span><br><span class="line">  to   space <span class="number">2560</span>K, <span class="number">0</span>% used [<span class="number">0x00000007e0400000</span>,<span class="number">0x00000007e0400000</span>,<span class="number">0x00000007e0680000</span>)</span><br><span class="line"> ParOldGen       total <span class="number">1398272</span>K, used <span class="number">1444</span>K [<span class="number">0x000000077fe00000</span>, <span class="number">0x00000007d5380000</span>, <span class="number">0x00000007d5380000</span>)</span><br><span class="line">  object space <span class="number">1398272</span>K, <span class="number">0</span>% used [<span class="number">0x000000077fe00000</span>,<span class="number">0x000000077ff693c8</span>,<span class="number">0x00000007d5380000</span>)</span><br><span class="line"> Metaspace       used <span class="number">8706</span>K, capacity <span class="number">10102</span>K, committed <span class="number">10240</span>K, reserved <span class="number">1058816</span>K</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">space</span>    <span class="title">used</span> 725<span class="title">K</span>, <span class="title">capacity</span> 809<span class="title">K</span>, <span class="title">committed</span> 896<span class="title">K</span>, <span class="title">reserved</span> 1048576<span class="title">K</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line">Caused by: java.lang.OutOfMemoryError: Metaspace</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;可以看到，当生成 369 个类后，程序便抛出了内存溢出异常( <strong>OutOfMemoryError</strong> )。但之前不同的是，元数据发生溢出，虚拟机抛出异常的异常会显示 <strong>Metaspace</strong>，而永久代是 <strong>PermGen space</strong>。</p>
<h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><p>&emsp;&emsp;运行时常量池 (Run-Time Constant Pool) 是方法区的一部分。Class 文件中的有一项信息称为常量池 (Constant Pool ，如下图所示)，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后存放到方法区的运行常量池中。</p>
<center>
    <img style="border-radius: 0.3125em; margin-top: 10px; width: 600px; height: 350px; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src="https://blog-1253514421.cos.ap-shanghai.myqcloud.com/20200721152817.png">
    <br>
</center>

<h3 id="Java堆、Java栈和方法区之间的关系"><a href="#Java堆、Java栈和方法区之间的关系" class="headerlink" title="Java堆、Java栈和方法区之间的关系"></a>Java堆、Java栈和方法区之间的关系</h3><p>&emsp;&emsp;最后，我们通过下面一个简单的示例，来展示下这三者之间存在的关系。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleHeap</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SimpleHeap</span><span class="params">(<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"id: "</span> + id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        SimpleHeap s1 = <span class="keyword">new</span> SimpleHeap(<span class="number">1</span>);</span><br><span class="line">        SimpleHeap s2 = <span class="keyword">new</span> SimpleHeap(<span class="number">2</span>);</span><br><span class="line">        s1.show();</span><br><span class="line">        s2.show();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;上述代码首先是声明了一个 SimpleHeap 类，并在 main( ) 方法中实例化了两个 SimpleHeap 类对象。此时，各局部变量和对象的关系如下图所示。SimpleHeap 对象的实例在堆中分配，描述 SimpleHeap 类的信息放在方法区，而 main( ) 方法中的 s1、s2 两个局部变量保存在 Java 栈中，并指向Java堆中的两个实例。</p>
<center>
    <img style="border-radius: 0.3125em; margin-top: 10px; width: 600px; height: 250px; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src="https://blog-1253514421.cos.ap-shanghai.myqcloud.com/20200716102039.png">
    <br>
</center>

<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>&emsp;&emsp;本文只简单记录了下 JVM 规范及部分 HotSpot的实现，没有十分详细的去深入探究这部分内容，因为 JVM 系列内容主要还是以我看书和查阅资料时所做的笔记。</p>
<p>&emsp;&emsp;值得注意的一点是，PrintGCDetails这个参数在 JDK 9 及以后版本已被废弃。最后再来理下方法区，永久代，元空间这三者的区别：</p>
<p>&emsp;&emsp;总的来说，我们可以将方法区想象成是接口，而永久代和元空间是其实现。正如我们开头提到过的，在 JDK 1.7 及以前的版本是以永久代做为方法区的实现；而在 JDK 1.8及以后版本则以元空间做方法区的实现。</p>
<p>&emsp;&emsp;永久代在堆里面，而元空间直接使用了本地内存。相应的 JDK 1.8 及以后，官方移除了永久代，以元空间做方法区实现，其中：常量池中的字符串常量池，直接留在了堆中；而其他的如类信息，静态信息则留在了元空间中,留在了直接 ( 本地 ) 内存。</p>
]]></content>
      <categories>
        <category>JVM</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>JetBrains 白嫖三个月激活码活动(二)</title>
    <url>/2020/03/12/jetbrains-quest-second-prize/</url>
    <content><![CDATA[<p>&emsp;&emsp;本篇紧跟上篇主题，是<strong>JetBrains</strong>新发布的第二个任务。让我们瞧一瞧新任务所带来了些什么有意思的题目吧。</p>
<h3 id="谜题一"><a href="#谜题一" class="headerlink" title="谜题一"></a>谜题一</h3><p>&emsp;&emsp;在北京时间2020年3月11日19点，JetBrains 公司又在官方推特发布了第二个<a href="https://twitter.com/jetbrains/status/1237694815283879943" target="_blank" rel="noopener">活动线索</a>。</p>
<center>
    <img style="border-radius: 0.3125em; margin-top: 10px; width: 600px; height: 250px; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src="https://blog-1253514421.cos.ap-shanghai.myqcloud.com/20200312051510.png">
    <br>
</center>

<p>&emsp;&emsp;这次与之前不同的是，初看会以为他们竟然是发的是一条莫名其妙的推，但是静下心来仔细观察下，马上就能有思路了，可以说这题比活动一的简单了。为什么这么讲呢？其实观察这条推文，我们可以发现顺着读我们是没办法理解它的意思的，但是一旦我们反着读，那么马上就能知道这条推文所想表达的意思了。于是我就简单的反转了下字符串，得到下图中的信息。</p>
<center>
    <img style="border-radius: 0.3125em; margin-top: 10px; width: 600px; height: 60px; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src="https://blog-1253514421.cos.ap-shanghai.myqcloud.com/20200312052353.png">
    <br>
</center>

<p>&emsp;&emsp;图中，首先我们可得到第一个线索：<strong>product domain-specific language</strong>，而与这条信息有关的只有MPS这款产品的<a href="https://www.jetbrains.com/mps/" target="_blank" rel="noopener">主页</a>。然后，第二个线索是： <strong>Dutch tax</strong>，虽然我自始自终都没搞懂第二句话是什么意思，但还是靠这个关键字在页面上找到唯一与<strong>Dutch tax</strong>相关的地方，如下图。</p>
<center>
    <img style="border-radius: 0.3125em; margin-top: 10px; width: 600px; height: 150px; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src="https://blog-1253514421.cos.ap-shanghai.myqcloud.com/20200312053717.png">
    <br>
</center>

<a id="more"></a>
<p>而第三个线索(那便是最后一句话)便是: 藏木于林。根据官方的提示，我们可以想到，要隐藏一段文字，那最好的方法便是将其融入背景，于是<strong>Cmd/Ctrl+A</strong>这个小提示便用上了。最后，我们便得到了这么一句话: <strong>This is our 20th year as a company,we have shared numbers in our JetBrains Annual report, sharing the section with 18,650 numbers will progress your quest.</strong></p>
<center>
    <img style="border-radius: 0.3125em; margin-top: 10px; width: 600px; height: 180px; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src="https://blog-1253514421.cos.ap-shanghai.myqcloud.com/20200312054706.png">
    <br>
</center>

<h3 id="谜题二"><a href="#谜题二" class="headerlink" title="谜题二"></a>谜题二</h3><p>&emsp;&emsp;根据谜题一得到的线索，我们打开google直接搜<strong>JetBrains 2019 Annual Report</strong>，于是得到了谜题二线索所在的页面。根据官方提示，我们得知通往下一关的钥匙肯定与18，650和section分享有关。而该页面唯一与这两个点有联系的，那便是<strong>7th Annual Hackathon</strong>这部分内容。整页只有这块内容是有分享按钮的，且当我们把这部分的数字全部相加时，会发现结果刚好等于18，650。因此，我们便得到了前往谜题三的钥匙：<code>I have found the JetBrains Quest! Sometimes you just need to look closely at the Haskell language, Hello,World! in the hackathon lego brainstorms project https://blog.jetbrains.com/blog/2019/11/22/jetbrains-7th-annual-hackathon/ #JetBrainsQuest https://www.jetbrains.com/company/annualreport/2019/ via @JetBrains</code></p>
<center>
    <img style="border-radius: 0.3125em; margin-top: 10px; width: 400px; height: 300px; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src="https://blog-1253514421.cos.ap-shanghai.myqcloud.com/20200312060418.png">
    <br>
</center>

<h3 id="谜题三"><a href="#谜题三" class="headerlink" title="谜题三"></a>谜题三</h3><p>&emsp;&emsp;谜题三其实十分简单，线索也都在谜题三的答案中给我们了。首先，我们进入谜题三所给的网站，然后找到<strong>lego brainstorms</strong>这部分。观察这部分的内容，我们会发现图片中存在着这样一段文字：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">d1D j00 kN0w J378r41n2 12 4lW4Y2 H1R1N9? ch3CK 0u7 73h K4r33r2 P493 4nD 533 1f 7H3r3 12 4 J08 F0r J00 0R 4 KW357 cH4LL3n93 70 90 fUr7h3r @ l3457.</span><br></pre></td></tr></table></figure><br>这句话其实是英语火星文，翻译过来便是：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Did you know Jetbrains is always hiring? Check out the careers page and see if there is a job for you or for quest challenge to go further atleast.</span><br></pre></td></tr></table></figure></p>
<center>
    <img style="border-radius: 0.3125em; margin-top: 10px; width: 400px; height: 300px; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src="https://blog-1253514421.cos.ap-shanghai.myqcloud.com/20200312062210.png">
    <br>
</center>

<h3 id="谜题四"><a href="#谜题四" class="headerlink" title="谜题四"></a>谜题四</h3><p>&emsp;&emsp;根据谜底三，我们直接进入 Jetbrains 的 <a href="https://www.jetbrains.com/careers/jobs/" target="_blank" rel="noopener">Job 页面</a>。当我们在Role选项框中选中<strong>any</strong>选项后，便得到了前进的线索。</p>
<center>
    <img style="border-radius: 0.3125em; margin-top: 10px; width: 400px; height: 100px; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src="https://blog-1253514421.cos.ap-shanghai.myqcloud.com/20200312063737.png">
    <br>
</center>

<p>&emsp;&emsp;点击该页面后，在跳转的页面中，我们可以找到通往谜题五的线索，便是：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">To progress with your quest what you’ll need:</span><br><span class="line">To check out what we have for game developers.</span><br><span class="line">Be geeky enough to remember how you used to cheat at Konami games.</span><br><span class="line">Try cheating on the page.</span><br></pre></td></tr></table></figure></p>
<h3 id="谜题五"><a href="#谜题五" class="headerlink" title="谜题五"></a>谜题五</h3><p>&emsp;&emsp;根据提示，我们打开进入谜题五的<a href="https://www.jetbrains.com/gamedev/" target="_blank" rel="noopener">页面</a>。此题的关键在于我们要知道科乐美的作弊码：<strong>↑↑↓↓←→←→BA</strong>(这秘籍应该没人不知道吧。在该页面中完成该秘籍后，会弹出一个弹球小游戏。击碎所有方块后，我们便能得到本次活动的激活码了。</p>
<center>
    <img style="border-radius: 0.3125em; margin-top: 10px; width: 400px; height: 200px; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src="https://blog-1253514421.cos.ap-shanghai.myqcloud.com/20200312064750.png">
    <br>
</center>

<h3 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h3><p>&emsp;&emsp;Jetbrains 这两个活动都挺有趣的，唯一令人难受的就是，想要能快速完美的解出每个问题，对于个人的英语水平要求真的有点高。反正有几个谜题我是一开始根本就没完全看懂。<br>&emsp;&emsp;最后附上领取成功的截图：</p>
<center>
    <img style="border-radius: 0.3125em; margin-top: 10px; width: 600px; height: 150px; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src="https://blog-1253514421.cos.ap-shanghai.myqcloud.com/20200312065540.png">
    <br>
</center>
]]></content>
      <categories>
        <category>日常折腾</category>
      </categories>
      <tags>
        <tag>白嫖</tag>
      </tags>
  </entry>
  <entry>
    <title>JetBrains 白嫖三个月激活码活动(一)</title>
    <url>/2020/03/11/jetbrains-quest-first-prize/</url>
    <content><![CDATA[<h3 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h3><p>&emsp;&emsp;今天下午突然收到朋友发来一个链接，是<strong>JetBrains</strong>公司发的一条<a href="https://twitter.com/jetbrains/status/1236986174075482113" target="_blank" rel="noopener">推特</a>。一开始我还是云里雾里的，结果后面听朋友讲，是JetBrains公司发起的一个小活动，可以白嫖三个月激活码。虽然我自己用的是学生账号，并不需要激活码，但是闲着无聊，还是去参加了这个小活动，其实还挺有意思的(可以看成是一个小型CTF比赛吧,2333。</p>
<center>
    <img style="border-radius: 0.3125em; margin-top: 10px; width: 600px; height: 250px; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src="https://blog-1253514421.cos.ap-shanghai.myqcloud.com/20200311180319.png">
    <br>
</center>

<a id="more"></a>
<h3 id="解谜"><a href="#解谜" class="headerlink" title="解谜"></a>解谜</h3><p>&emsp;&emsp;整个活动由好几个谜题构成，下面我们就一个一个谜题展开来慢慢叙述吧。</p>
<h4 id="谜题一"><a href="#谜题一" class="headerlink" title="谜题一"></a>谜题一</h4><p>&emsp;&emsp;第一个谜题其实就是解出上面推特中的隐藏信息。相信稍微了解<strong>CTF</strong>内容的人，都能很快的猜到，这串数字肯定是能转译成文字的（要不然根本没法往下面解啊。于是，我试了下将其翻译成<strong>ascii</strong>，结果还真一次就过了（随便搜一个十六进制转ascii码的网站就行了）。于是，我们便有了下一步的思路，那便是线索就在官网的代码中。</p>
<center>
    <img style="border-radius: 0.3125em; margin-top: 10px; width: 600px; height: 250px; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src="https://blog-1253514421.cos.ap-shanghai.myqcloud.com/20200311181101.png">
    <br>
</center>

<h4 id="谜题二"><a href="#谜题二" class="headerlink" title="谜题二"></a>谜题二</h4><p>&emsp;&emsp;前往下一个阶段的线索，就出在 JetBrains 官网的源码中。首先，我们进入 <a href="https://www.jetbrains.com/" target="_blank" rel="noopener">JetBrains 官网首页</a>，然后右键获取网页的源代码。当你看到源码的时候，肯定会一脸头疼，毕竟你要从中找到一个还不知道是什么的线索。但是，可能是官方也并不想游戏难度太大，只要你有足够的耐心，慢慢往下找，你会很快就找到谜题二的答案。</p>
<center>
    <img style="border-radius: 0.3125em; margin-top: 10px; width: 600px; height: 200px; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src="https://blog-1253514421.cos.ap-shanghai.myqcloud.com/20200311181949.png">
    <br>
</center>

<h4 id="谜题三"><a href="#谜题三" class="headerlink" title="谜题三"></a>谜题三</h4><p>&emsp;&emsp;从上图我圈出来的文字中可以得知，JetBrains有很多产品，但是在他们的 “ 产品 “ 页面上有一个看起来像个玩笑，我们需要找到它，而且他们还提醒，使用<strong>chrome的隐身模式</strong>。于是，我们打开隐身模式，进入到<a href="https://www.jetbrains.com/products.html" target="_blank" rel="noopener">产品页面</a>。在众多产品中，我们可以发现这么一个异类(下图中我已圈出)。为什么这么讲呢，因为大家可以观察其他产品都会介绍该产品是干什么的，而只有<strong>JK</strong>这个应用，只有<strong>Dare to learn more</strong>这行字，而JK这两个字容易让人联想到<strong>Joke</strong>这个词，因此我们尝试的去点击下它，获取到了前往下一阶段的线索。</p>
<center>
    <img style="border-radius: 0.3125em; margin-top: 10px; width: 600px; height: 300px; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src="https://blog-1253514421.cos.ap-shanghai.myqcloud.com/20200311182540.png">
    <br>
</center>

<h4 id="谜题四"><a href="#谜题四" class="headerlink" title="谜题四"></a>谜题四</h4><p>&emsp;&emsp;前三个谜题，都可谓没什么难度，但是最后几个就开始稍微有点意思了。第四个的问题，就在点击<strong>JK</strong>产品后弹出的信息框中。</p>
<center>
    <img style="border-radius: 0.3125em; margin-top: 10px; width: 600px; height: 300px; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src="https://blog-1253514421.cos.ap-shanghai.myqcloud.com/20200311183212.png">
    <br>
</center>

<p>&emsp;&emsp;由内容可知，他们给出了一个链接（ <a href="https://jb.gg/###" target="_blank" rel="noopener">https://jb.gg/###</a> ），但是该链接目前有三位数字不知道。而我们的任务就是解答出他下面的问题：500 - 5000之间的<strong>质数</strong>有多少个。这里，我用欧拉筛快速查了遍，于是<a href="https://jb.gg/574" target="_blank" rel="noopener">前往第五个谜题的线索</a>就有了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int MAXN &#x3D; 10000000 + 5;</span><br><span class="line"></span><br><span class="line">int book[MAXN], vis[MAXN];</span><br><span class="line"></span><br><span class="line">void find(int num) &#123;</span><br><span class="line">    int ct &#x3D; 1;</span><br><span class="line">    book[1] &#x3D; 2;</span><br><span class="line">    vis[1] &#x3D; 1;</span><br><span class="line">    for (int i &#x3D; 2; i &lt;&#x3D; num; i++) &#123;</span><br><span class="line">        if (!vis[i])</span><br><span class="line">            book[ct++] &#x3D; i;</span><br><span class="line">        for (int j &#x3D; 1; j &lt;&#x3D; ct &amp;&amp; i * book[j] &lt;&#x3D; num; j++) &#123;</span><br><span class="line">            vis[i * book[j]] &#x3D; 1;</span><br><span class="line">            if (i % book[j] &#x3D;&#x3D; 0)</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    find(5000);</span><br><span class="line">    int cnt &#x3D; 0;</span><br><span class="line">    for (int i &#x3D; 500; i &lt;&#x3D; 5000; ++i)</span><br><span class="line">        if (!vis[i])</span><br><span class="line">            ++cnt;</span><br><span class="line">    cout &lt;&lt; cnt &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="谜题五"><a href="#谜题五" class="headerlink" title="谜题五"></a>谜题五</h4><p>&emsp;&emsp;这个谜题其实我是没有解出来，是特意去查了下的，因为该阶段需要你比较了解<strong>JetBrains</strong>的产品内容，而我对于 JetBrains 并不熟悉，只用过几款产品罢了。 </p>
<center>
    <img style="border-radius: 0.3125em; margin-top: 10px; width: 600px; height: 500px; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src="https://blog-1253514421.cos.ap-shanghai.myqcloud.com/20200311184027.png">
    <br>
</center>

<p>&emsp;&emsp;即便是像我这种不熟悉的人，也能知道谜底肯定与<strong>YT</strong>这款产品有关。但是，也仅此而已。因此我去查了查图里那串字符到底是什么意思，还真让我搜到了。<br>&emsp;&emsp;图中<strong>YT</strong>那个Logo其实是YouTrack在JebBrains网站的问题区。知道这个后，那么下面那串字符也就很容易知道是什么了，那当然就是问题的编号咯。于是，我们得到了第五个谜题的<a href="https://youtrack.jetbrains.com/issue/MPS-31816" target="_blank" rel="noopener">答案</a></p>
<center>
    <img style="border-radius: 0.3125em; margin-top: 10px; width: 600px; height: 100px; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src="https://blog-1253514421.cos.ap-shanghai.myqcloud.com/20200311185056.png">
    <br>
</center>

<h4 id="谜题六"><a href="#谜题六" class="headerlink" title="谜题六"></a>谜题六</h4><p>&emsp;&emsp;这个谜题就是我们最后一个需要解答的问题了，答出后我们就能获取到三个月的激活码了。谜题是官方给出的一句话：<strong>The key is to think back to the beginning.” – The JetBrains Quest team</strong> 和一长串字符(乱码?)：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Qlfh$#Li#|rx#duh#uhdglqj#wklv#|rx#pxvw#kdyh#zrunhg#rxw#krz#wr#ghfu|sw#lw1#Wklv#lv#rxu#lvvxh#wudfnhu#ghvljqhg#iru#djloh#whdpv1#Lw#lv#iuhh#iru#xs#wr#6#xvhuv#lq#Forxg#dqg#iru#43#xvhuv#lq#Vwdqgdorqh&#x2F;#vr#li#|rx#zdqw#wr#jlyh#lw#d#jr#lq#|rxu#whdp#wkhq#zh#wrwdoo|#uhfrpphqg#lw1#|rx#kdyh#ilqlvkhg#wkh#iluvw#Txhvw&#x2F;#qrz#lw“v#wlph#wr#uhghhp#|rxu#iluvw#sul&#125;h1#Wkh#frgh#iru#wkh#iluvw#txhvw#lv#‟WkhGulyhWrGhyhors†1#Jr#wr#wkh#Txhvw#Sdjh#dqg#xvh#wkh#frgh#wr#fodlp#|rxu#sul&#125;h1#kwwsv&#x3D;22zzz1mhweudlqv1frp2surpr2txhvw2</span><br></pre></td></tr></table></figure><br>&emsp;&emsp;在这个谜题里，官方告诉我们解题的关键便是要重新去思考。看到这，官方在谜题二中挖的一个坑在便被填上了。大家可以在看看谜题二中那篇文的最后一段。下图我已用红色圈出来了，这里有个key：<strong>Good luck! == Jrrg#oxfn$</strong>，而这个key就是我们解这题的关键。</p>
<center>
    <img style="border-radius: 0.3125em; margin-top: 10px; width: 600px; height: 150px; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src="https://blog-1253514421.cos.ap-shanghai.myqcloud.com/20200311185916.png">
    <br>
</center>

<p>&emsp;&emsp;观察<strong>Good luck! == Jrrg#oxfn$</strong>这个字符串，我们可以发现它是一个等式，这便意味着我们解题的关键就在于为什么它们会相等。稍微思考片刻，我发现了一个疑点：<strong>oo</strong> —&gt; <strong>rr</strong>。凭此，我初步怀疑这是一个简单的解密题，而且还是个凯撒码。于是，我尝试着在草稿纸上模拟移位了下，发现确实如此。由此，我们就能很快的去解码官方给的那串字符了。这里我用C++简单模拟了下，如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    string str &#x3D; &quot;&quot;;&#x2F;&#x2F; 这里放官方那串字符</span><br><span class="line">    for (int i &#x3D; 0; i &lt; str.length(); ++i) &#123;</span><br><span class="line">        char c &#x3D; str[i];</span><br><span class="line">        if (isalpha(c)) &#123;</span><br><span class="line">            c -&#x3D; 3;</span><br><span class="line">            if ((c &gt;&#x3D; 62 &amp;&amp; c &lt; 65) || (c &gt; 94 &amp;&amp; c &lt; 97))</span><br><span class="line">                c +&#x3D; 26;</span><br><span class="line">            else if ((c &gt; 90 &amp;&amp; c &lt;&#x3D; 93) || (c &gt; 122 &amp;&amp; c &lt;&#x3D; 125))</span><br><span class="line">                c -&#x3D; 26;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            c -&#x3D; 3;</span><br><span class="line">            if (isalpha(c))</span><br><span class="line">                c &#x3D; toupper(c);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        str[i] &#x3D; c;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>&emsp;&emsp;运行程序后，我们便完成了本次活动。从运行结果中，我们可以获得本次活动的密钥以及<a href="https://www.jetbrains.com/promo/quest/" target="_blank" rel="noopener">激活的地址</a>。这里为了保留点乐趣，我把密钥打码了，大家可以自己试试。</p>
<center>
    <img style="border-radius: 0.3125em; margin-top: 10px; width: 600px; height: 100px; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src="https://blog-1253514421.cos.ap-shanghai.myqcloud.com/20200311191201.png">
    <br>
</center>

<h3 id="领取活动奖品"><a href="#领取活动奖品" class="headerlink" title="领取活动奖品"></a>领取活动奖品</h3><p>&emsp;&emsp;打开之前获得的网址，在里面输入自己的邮箱以及刚获取到的密钥，当成功跳转到含有下面图片内容的页面时，你就成功领取到密钥了。只需稍等片刻，然后进入自己所填的邮箱找到<strong>JetBrains</strong>给你发的邮件，里面就包含了三个月的激活码。如果没看见，建议去垃圾邮件里看看。（我用的网易邮箱竟然直接把它收到垃圾邮件里去了，亏我还等了很久，因为出bug了。</p>
<center>
    <img style="border-radius: 0.3125em; margin-top: 10px; width: 600px; height: 400px; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src="https://blog-1253514421.cos.ap-shanghai.myqcloud.com/20200311191555.png">
    <br>
</center>

<p>&emsp;&emsp;最后，下面给出我收到的含有三个月激活码的邮件。</p>
<center>
    <img style="border-radius: 0.3125em; margin-top: 10px; width: 600px; height: 400px; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src="https://blog-1253514421.cos.ap-shanghai.myqcloud.com/20200311192018.png">
    <br>
</center>]]></content>
      <categories>
        <category>日常折腾</category>
      </categories>
      <tags>
        <tag>白嫖</tag>
      </tags>
  </entry>
  <entry>
    <title>macOS Catalina 10.15版本下使用Parallels 15导致电脑无声音问题</title>
    <url>/2020/03/10/parallels-voice-problem/</url>
    <content><![CDATA[<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>&emsp;&emsp;最近在使用<strong>Parallels 15</strong>时，经常发生笔记本无声音的问题。在未打开Parallels 15时，电脑声音输出是正常的，但是一打开这个软件，电脑声音就时有时无。因为我安装了<strong>Sound Control</strong>，所以我可以观察到音乐在后台是在正常播放的，但是却没办法输出，令人甚是头疼。<br><a id="more"></a></p>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>&emsp;&emsp;为了解决这个问题，我查找了挺多信息，找到了三种解决方法（确切的说是两种，因为前两种方法其实是一样的），但是却还是没整明白问题处在哪里。</p>
<h4 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h4><p>&emsp;&emsp;第一种方法就是打开电脑的<strong>Activity Monitor</strong>，然后找到<strong>coreaudiod</strong>这个进程（它是MacOS的核心音频进程），找到后将其结束即可，它在被你结束进程后，将会自动启动。</p>
<center>
    <img style="border-radius: 0.3125em; margin-top: 10px; width: 600px; height: 300px; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src="https://blog-1253514421.cos.ap-shanghai.myqcloud.com/20200310201311.png">
    <br>
</center>

<h4 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h4><p>&emsp;&emsp;第二种方法其实就是第一种方法的简化版本，它们的原理其实都是一样的，都是结束<strong>coreaudiod</strong>这个进程。首先你需要打开你的终端，然后输入：<code>sudo killall coreaudiod</code> 即可。该方法十分便捷，你可以把这个命令写成一个脚本，遇到问题时直接执行就可以了。</p>
<h4 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h4><p>&emsp;&emsp;第三种方法可以说是一劳永逸的方法（至少在我使用的这段时间，暂时没有再出现过问题）。该方法是我在<strong>Parallels</strong>官方论坛中发现的，在论坛中可以看见，有许多人都遇到了这个问题，因此看起来可能是兼容的问题？？？有兴趣的人可以浏览<a href="https://forum.parallels.com/threads/when-a-vm-starts-earpods-stops-functioning.348837/#post-862582" target="_blank" rel="noopener">链接 1 🔗</a>中的#21楼回复和<a href="https://forum.parallels.com/threads/no-sound-at-catalina-10-15-2-parallels-desktop-15-1-2-for-mac.349141/page-2" target="_blank" rel="noopener">链接 2 🔗</a>中的#18楼的回复。</p>
<p>&emsp;&emsp;下面，我将描述该如何去解决这个问题：</p>
<p>I、首先，<strong>shut down</strong>当前<strong>Parallels 15</strong>所在运行的环境。如果不知道该怎么关机的话，可以看下图。长点对应环境，就会显示操作栏，选中对应选项即可。</p>
<center>
    <img style="border-radius: 0.3125em; margin-top: 10px; width: 600px; height: 300px; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src="https://blog-1253514421.cos.ap-shanghai.myqcloud.com/20200310202746.png">
    <br>
</center>

<p>II、然后，打开当前环境的偏好设置，点击如下图选项。</p>
<center>
    <img style="border-radius: 0.3125em; margin-top: 10px; width: 200px; height: 200px; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src="https://blog-1253514421.cos.ap-shanghai.myqcloud.com/20200310203533.png">
    <br>
</center>

<p>III、在偏好设置中，找到<strong>Hardware</strong>选项，然后选中<strong>CPU&amp;Memory</strong>。点击左下角的<strong>小锁🔒</strong>，以来解锁一些操作。如果你没有执行第一步的话，这一步可能会有你需要关机才能执行某些操作的提示。最后，找到<strong>Hypervisor</strong>选项，点击下拉框，选中<strong>Apple</strong>就大功告成了。</p>
<center>
    <img style="border-radius: 0.3125em; margin-top: 10px; width: 600px; height: 400px; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src="https://blog-1253514421.cos.ap-shanghai.myqcloud.com/20200310203746.png">
    <br>
</center>

<p>Ⅳ、重启<strong>Parallels 15</strong>应用，现在你就会发现声音播放正常了（如果还是无声音的话，使用下方法一或方法二）。</p>
]]></content>
      <categories>
        <category>日常折腾</category>
      </categories>
      <tags>
        <tag>macOS</tag>
        <tag>parallels</tag>
      </tags>
  </entry>
  <entry>
    <title>白嫖教育版 Microsoft Office 365</title>
    <url>/2020/02/23/microsoft-office/</url>
    <content><![CDATA[<p>&emsp;&emsp;记录下白嫖教育版 <strong>Microsoft Office 365</strong> 的经过，方便以后如果遗忘掉，在换新机或者重装后需要再找攻略。此方法是通过教育邮箱了获取教育版的Office 365，因此该方法的优势在于只要主账号不过期，那么子账号其实是可以一直用下去的，相当于永久账号了（一次注册，永久使用。</p>
<a id="more"></a>
<h3 id="第一步：-获取临时邮箱"><a href="#第一步：-获取临时邮箱" class="headerlink" title="第一步： 获取临时邮箱"></a>第一步： 获取临时邮箱</h3><p>&emsp;&emsp;首先，我们注册教育邮箱前，需要去获取个临时的邮箱来接受验证码。这里我是去<a href="http://24mail.chacuo.net/" target="_blank" rel="noopener">查错网</a>，生成了一个临时邮箱ID，你可以用自己创建的ID，也可以用站方随机生成的ID。如下图所示，在临时邮箱ID那个框框中，自定义一个自己的ID后，点击下设置邮箱即可。</p>
<center>
    <img style="border-radius: 0.3125em; margin-top: 10px; width: 600px; height: 150px; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src="https://blog-1253514421.cos.ap-shanghai.myqcloud.com/microsoft-office-img1.png">
    <br>
</center>

<h3 id="第二部：注册-Office-365-教育版账号"><a href="#第二部：注册-Office-365-教育版账号" class="headerlink" title="第二部：注册 Office 365 教育版账号"></a>第二部：注册 Office 365 教育版账号</h3><p>&emsp;&emsp;首先，打开<strong>Office 365 教育版</strong>的<a href="https://signup.microsoft.com/signup?sku=faculty" target="_blank" rel="noopener">注册网页</a>。然后，在该网页中，你可以看见官方要求输入<strong>学校电子邮件地址</strong>的框框，这里你需要用到你在第一步申请的<strong>临时邮箱ID</strong>，例如：我在第一步中申请的临时邮箱ID - <strong>beqnlp82370</strong>。有了临时邮箱ID后，你只需在ID后跟 <strong>@stu.mao.office.gy</strong>，即 <strong>beqnlp82370@stu.mao.office.gy</strong>（这里的邮箱ID换成你自己的）。最后到达用户信息界面，如下图所示。</p>
<center>
    <img style="border-radius: 0.3125em; margin-top: 10px; width: 600px; height: 500px; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src="https://blog-1253514421.cos.ap-shanghai.myqcloud.com/microsoft-office-img2.png">
    <br>
</center>

<p>&emsp;&emsp;这里面，最重要的是这个验证码的，其他随意。验证码会发送到下图这里，大概需要五分钟以上才会接受到，因此在五分钟后，你可以时刻查看下当前的邮件数量，如果邮件数量不是0，而又页面中没有显示邮件时，刷新当前页面即可（这部分耗时最长，建议耐心等待下，我是等了快15分钟才收到注册码的。如果第一个五分钟没有收到验证码，建议重新发送注册码，然后再耐心等待，如还不行，可尝试换个临时邮箱ID）。</p>
<center>
    <img style="border-radius: 0.3125em; margin-top: 10px; width: 600px; height: 250px; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src="https://blog-1253514421.cos.ap-shanghai.myqcloud.com/microsoft-office-img3.png">
    <br>
</center>

<h3 id="第三步：访问面板组"><a href="#第三步：访问面板组" class="headerlink" title="第三步：访问面板组"></a>第三步：访问面板组</h3><p>&emsp;&emsp;首先进入<a href="https://account.activedirectory.windowsazure.com/r#/groups" target="_blank" rel="noopener">面板组</a>，然后找到<strong>我加入的组</strong>这一栏，你会发现当前<strong>我加入的组</strong>为空，此时你就需要点击<strong>加入组</strong>，找到<strong>Office 365</strong>这个组，点击加入组，在弹出来的框中任意输入提交即可，管理员会自动审核通知，因此你会秒进组。操作到这一步，你就已经完成的差不多了。</p>
<center>
    <img style="border-radius: 0.3125em; margin-top: 10px; width: 600px; height: 400px; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src="https://blog-1253514421.cos.ap-shanghai.myqcloud.com/microsoft-office-img4.png">
    <br>
</center>

<h3 id="第四步：下载-Office-365"><a href="#第四步：下载-Office-365" class="headerlink" title="第四步：下载 Office 365"></a>第四步：下载 Office 365</h3><p>&emsp;&emsp;打开 Office 365 的<a href="https://signup.microsoft.com/" target="_blank" rel="noopener">登录网址</a>，输入你之前注册的账号密码后，他会跳转到绑定手机号的页面，如下图所示。你可以绑定，也可以不绑定（点击取消即可），不绑定的话，你每次登录都可能会重定向到该页面，这里看个人喜好吧。</p>
<center>
    <img style="border-radius: 0.3125em; margin-top: 10px; width: 600px; height: 200px; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src="https://blog-1253514421.cos.ap-shanghai.myqcloud.com/microsoft-office-img5.png">
    <br>
</center>

<p>&emsp;&emsp;之后，进入 Office 365 的主页，下载安装自己需要的应用。安装好后，登录自己的教育邮箱账号便可以安心使用了。</p>
<center>
    <img style="border-radius: 0.3125em; margin-top: 10px; width: 600px; height: 400px; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src="https://blog-1253514421.cos.ap-shanghai.myqcloud.com/microsoft-office-img6.png">
    <br>
</center>


<h3 id="注意事项-一定要看"><a href="#注意事项-一定要看" class="headerlink" title="注意事项(一定要看)"></a>注意事项(一定要看)</h3><p>&emsp;&emsp;因为用的是教育邮箱，主账号(即管理员账号)是可以看到<strong>所有人</strong>的 <strong>OneDrive</strong> 内容的，因此千万不要往该账号的 OneDrive 中上传个人资料，以免造成不可挽回的损失。你可以将 OneDrive 账号替换成个人私用的，这样的话，就可避免上述问题。</p>
]]></content>
      <categories>
        <category>日常折腾</category>
      </categories>
      <tags>
        <tag>白嫖</tag>
      </tags>
  </entry>
  <entry>
    <title>最大子序列和</title>
    <url>/2020/02/15/maxSubSeqSum/</url>
    <content><![CDATA[<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>给定一个包含N个整数的序列：<script type="math/tex">\{A_1, A_2, A_3……A_N\}，</script> 求该序列中的子序列的最大和，即：<script type="math/tex">sum = max(0, \sum_j^{k=i}A_k)</script></p>
<h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h4><p><strong>input</strong>: 4, -3, 5, -2, -1, 2, 6, -2<br><strong>output</strong>: 11</p>
<a id="more"></a>
<h3 id="暴力法一"><a href="#暴力法一" class="headerlink" title="暴力法一"></a>暴力法一</h3><p>&emsp;&emsp;暴力法一是最简单粗暴的方法，通过三重嵌套循环，枚举每个子序列的大小，然后记录并返回最终值，其复杂度: <strong>O(n^3)</strong>。<br>&emsp;&emsp;第一个循环 <strong>i</strong> 指定子列左端的下标，第二个循环 <strong>j</strong> 指定子列右端的下标，第三个循环 <strong>k</strong> 用来累加计算 i-&gt;j 的和，<strong>thisSum</strong> 记录A[i]-&gt; A[j]的子列和，<strong>maxSum</strong> 记录最大的累加和。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int maxSubSeqSum(int A[], int N) &#123;</span><br><span class="line">    int thisSum, maxSum &#x3D; 0;</span><br><span class="line">    int i, j, k;</span><br><span class="line"></span><br><span class="line">    for (i &#x3D; 0; i &lt; N; ++i) &#123;</span><br><span class="line">        for (j &#x3D; i; j &lt; N; ++j) &#123;</span><br><span class="line">            thisSum &#x3D; 0;</span><br><span class="line">            for (k &#x3D; i; k &lt;&#x3D; j; ++k) &#123;</span><br><span class="line">                thisSum +&#x3D; A[k];</span><br><span class="line">                if (thisSum &gt; maxSum)</span><br><span class="line">                    maxSum &#x3D; thisSum;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return maxSum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="暴力法二"><a href="#暴力法二" class="headerlink" title="暴力法二"></a>暴力法二</h3><p>&emsp;&emsp;暴力法二是在暴力法一的基础上进行了优化，将三重循环减到两重，大大减少了循环次数，因此其复杂度: <strong>O(n^2)</strong>。<br>&emsp;&emsp;这个方法少了第 k 个循环，合理优化了代码，对于相同的 i ，不同的 j ，只需<strong>在 j-1 次的基础上累加当前项</strong>即可。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int maxSubSeqSum(int A[], int N) &#123;</span><br><span class="line">    int thisSum, maxSum &#x3D; 0;</span><br><span class="line">    int i, j;</span><br><span class="line"></span><br><span class="line">    for (i &#x3D; 0; i &lt; N; ++i) &#123;</span><br><span class="line">        thisSum &#x3D; 0;</span><br><span class="line">        for (j &#x3D; i; j &lt; N; ++j) &#123;</span><br><span class="line">            thisSum +&#x3D; A[j];</span><br><span class="line">            if (thisSum &gt; maxSum)</span><br><span class="line">                maxSum &#x3D; thisSum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return maxSum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="分治法"><a href="#分治法" class="headerlink" title="分治法"></a>分治法</h3><p>&emsp;&emsp;运用分而治之的思想，主要是通过<strong>递归</strong>来实现的，当数据量很大时，会占用十分大的内存消耗，因此该方法并不能很好的工作，复杂度： <strong>O(nlogn)</strong>。</p>
<p>&emsp;&emsp;<strong>解题思路</strong>：首先将整个序列不断<strong>切半分</strong>，直到得到个只含<strong>一个数的子序列</strong>，如下图所示。</p>
<center>
    <img style="border-radius: 0.3125em; margin-top: 15px; width: 500px; height: 90px; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src="https://blog-1253514421.cos.ap-shanghai.myqcloud.com/maxSubSeqSum-img1.png">
    <br>
</center>

<p>然后将其中的每个数和其左或右边的数进行<strong>相加</strong>，用相加后得到的值和原值进行<strong>比较</strong>，并<strong>保留较大的一方</strong>。例如以下图所示：4 + (-3) = 1 &lt; 4 ，保留 4; 5 + (-2) = 3 &lt; 5，保留 5 ；(-1) + 2 = 1 &lt; 2，保留 2 ； 6 + (-2) = 4 &lt; 6 ，保留 6。 这里每一步的计算，我们都要保留最大的那个和。</p>
<center>
    <img style="border-radius: 0.3125em; margin-top: 15px; width: 400px; height: 110px; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src="https://blog-1253514421.cos.ap-shanghai.myqcloud.com/maxSubSeqSum-img2.png">
    <br>
</center>

<p>利用上述的思想，重复第二步操作便可得下图结果，即左边从 4 开始向右走，不断累加到 5 便停止，最终得到的 6 便是该阶段所能获得的最大子列和；而右边因为是从 -1 开始的，当值不大于 0 时，我们不考虑，因此从 2 开始向右走， 不断累加到6便停止，最终得到的 8 便是该阶段所能得到的最大子列和，将其与左边的进行比较，保留较大的值即可。</p>
<center>
    <img style="border-radius: 0.3125em; margin-top: 15px; width: 500px; height: 130px; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src="https://blog-1253514421.cos.ap-shanghai.myqcloud.com/maxSubSeqSum-img3.png">
    <br>
</center>

<p>通过不断的回溯，最终我们需要考虑的一个跨越边界的问题，即左右两边的值相加是否能得到一个更大的值。如下图所示，从 -2 开始，一直累加到 4 为止，此时我们便能得到左侧的最大值，而从 -1 开始，一直累加到 6 为止，此时我们便能得到右侧的最大值，将它们相加与之前得到的左右两边的最大值比较，其中较大的值便是我们所求问题的答案。</p>
<center>
    <img style="border-radius: 0.3125em; margin-top: 15px; width: 500px; height: 150px; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src="https://blog-1253514421.cos.ap-shanghai.myqcloud.com/maxSubSeqSum-img4.png">
    <br>
</center>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int maxSubSeqSum(int A[], int l, int r) &#123;</span><br><span class="line">    &#x2F;&#x2F; 当分割到只剩一个元素时，</span><br><span class="line">    &#x2F;&#x2F; 判断其是否大于0，如果大于0的话就保留其值并返回，否则返回0</span><br><span class="line">    if (l &#x3D;&#x3D; r)</span><br><span class="line">        if (A[l] &gt; 0)</span><br><span class="line">            return A[l];</span><br><span class="line">        else</span><br><span class="line">            return 0;</span><br><span class="line"></span><br><span class="line">    int mid &#x3D; (l + r) &#x2F; 2;</span><br><span class="line">    &#x2F;&#x2F; 获取每个阶段左右两边的最大值</span><br><span class="line">    int maxLeftSum &#x3D; maxSubSeqSum(A, l, mid);</span><br><span class="line">    int maxRightSum &#x3D; maxSubSeqSum(A, mid + 1, r);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 计算左边子序列和的最大值</span><br><span class="line">    int maxLeftBorderSum &#x3D; 0, leftBorderSum &#x3D; 0;</span><br><span class="line">    for (int i &#x3D; mid; i &gt;&#x3D; l; --i) &#123;</span><br><span class="line">        leftBorderSum +&#x3D; A[i];</span><br><span class="line">        if (leftBorderSum &gt; maxLeftBorderSum)</span><br><span class="line">            maxLeftBorderSum &#x3D; leftBorderSum;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 计算右边子序列和的最大值</span><br><span class="line">    int maxRightBorderSum &#x3D; 0, rightBorderSum &#x3D; 0;</span><br><span class="line">    for (int i &#x3D; mid + 1; i &lt;&#x3D; r; ++i) &#123;</span><br><span class="line">        rightBorderSum +&#x3D; A[i];</span><br><span class="line">        if (rightBorderSum &gt; maxRightBorderSum)</span><br><span class="line">            maxRightBorderSum &#x3D; rightBorderSum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return max(maxLeftSum, </span><br><span class="line">            max(maxRightSum, </span><br><span class="line">                maxLeftBorderSum + maxRightBorderSum));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="扫描法"><a href="#扫描法" class="headerlink" title="扫描法"></a>扫描法</h3><p>&emsp;&emsp;因为最大连续子序列和只可能是以数组下标0～N-1中某个作为结尾。当遍历到第i个元素时，将其和当前子序列和的值(thisSum)相加，然后判断其是否大于0：如果大于0，则更新最大子序列和(maxSum)的值；否则，更新当前子序列和的值为0，算法复杂度：<strong>O(n)</strong>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int maxSubSeqSum(int A[], int N) &#123;</span><br><span class="line">    int thisSum &#x3D; 0, maxSum &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    for (int i &#x3D; 0; i &lt; N; ++i) &#123;</span><br><span class="line">        &#x2F;&#x2F; 向右累加</span><br><span class="line">        thisSum +&#x3D; A[i];</span><br><span class="line">        if (thisSum &gt; maxSum)</span><br><span class="line">            maxSum &#x3D; thisSum;</span><br><span class="line">        else if (thisSum &lt; 0)  &#x2F;&#x2F; 如果为负则舍弃</span><br><span class="line">            thisSum &#x3D; 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return maxSum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>分治</tag>
        <tag>动态规划</tag>
        <tag>扫描法</tag>
      </tags>
  </entry>
  <entry>
    <title>vscode搭建c/c++调试环境(MacOS)</title>
    <url>/2020/02/13/mac-vscode-c++/</url>
    <content><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>&emsp;&emsp;vscode相比起IDE，其轻便、插件丰富、功能繁多是我选择其作为C++日常使用的编辑器的原因。对于我这种，只写写一些简单程序，用来学习算法和数据结构，并且空闲时间，还能写写python脚本和网站，vscode可谓首选。</p>
<a id="more"></a>
<h3 id="下载与安装"><a href="#下载与安装" class="headerlink" title="下载与安装"></a>下载与安装</h3><p>&emsp;&emsp;<a href="https://code.visualstudio.com/" target="_blank" rel="noopener">vscode</a>十分的方便，直接去官网下载即可。下载后好，一路点击继续，等到安装结束即可。</p>
<center>
    <img style="border-radius: 0.3125em; margin-top: 10px; width: 400px; height: 250px; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src="https://blog-1253514421.cos.ap-shanghai.myqcloud.com/image-1-1600x667.png">
    <br>
</center>

<h3 id="插件推荐"><a href="#插件推荐" class="headerlink" title="插件推荐"></a>插件推荐</h3><h4 id="C-C"><a href="#C-C" class="headerlink" title="C/C++"></a>C/C++</h4><p>&emsp;&emsp;如果想在vscode上快速的开始使用C++编写程序，那么<strong>C/C++</strong>这款插件是微软官方发布的一款专门针对C和C++的插件。打开vscode，然后点击插件图标，在搜索框中直接搜索<strong>C/C++</strong>，下载数量和评分最高的那个就是了（一般搜出来的第一个就是）。</p>
<center>
    <img style="border-radius: 0.3125em; margin-top: 10px; width: 500px; height: 200px; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src="https://blog-1253514421.cos.ap-shanghai.myqcloud.com/BCAAAAE4-8B7F-4A42-B9FB-535725BBAADF.png">
    <br>
</center>

<h4 id="Chinese-Simplified"><a href="#Chinese-Simplified" class="headerlink" title="Chinese (Simplified)"></a>Chinese (Simplified)</h4><p>&emsp;&emsp;<strong>Chinese (Simplified)</strong> 是微软官方发布的用来解决vscode汉化问题的一款插件，如果你对满屏的英文感觉头疼的话，那建议可以尝试下安装这款插件哦，安装方式同上。</p>
<center>
    <img style="border-radius: 0.3125em; margin-top: 10px; width: 500px; height: 180px; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src="https://blog-1253514421.cos.ap-shanghai.myqcloud.com/302A82E3-752E-4C3A-BFD4-020FAA60B1F8.png">
    <br>
</center>

<h4 id="CodeLLDB"><a href="#CodeLLDB" class="headerlink" title="CodeLLDB"></a>CodeLLDB</h4><p>&emsp;&emsp;如果在Mac OS X Catalina版本上这款插件是必须安装的，不安装<strong>CodeLLDB</strong> 这款插件的话，那么你就会遇到无法调试程序这个问题。原因是苹果在macOS Catalina上取消了对lldb支持，于是我们就必须寻找对应的替代品。为了解决这个问题，我谷歌了挺久，最后在官方Github上的<a href="https://github.com/microsoft/vscode-cpptools/issues/3829" target="_blank" rel="noopener">issue</a>中发现了解决方法。官方给出的解决方法就是安装这款插件来替代X-Code中的lldb-mi。</p>
<center>
    <img style="border-radius: 0.3125em; margin-top: 10px; width: 500px; height: 180px; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src="https://blog-1253514421.cos.ap-shanghai.myqcloud.com/3BC45F5E-E5FE-49E3-9EA2-38AC26114321.png">
    <br>
</center>

<h3 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h3><p>&emsp;&emsp;首先，我们需要一个专门存放C/C++代码的地方，以后要编写C++代码时，直接在vscode打开对应的文件夹就行了。这样做的好处就是，不必反复的配置运行环境。如下图所示，<strong>.vscode</strong>这个文件夹是用来存放环境配置文件的，而<strong>demo</strong>这个文件夹，是用来存放自己的程序的，你可以创建多个类似与demo的这种文件夹。</p>
<center>
    <img style="border-radius: 0.3125em; margin-top: 10px; width: 500px; height: 180px; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src="https://blog-1253514421.cos.ap-shanghai.myqcloud.com/84451EF7-5FB4-49EE-A3CF-8A6D3578201C.png">
    <br>
</center>

<h4 id="配置-launch-json"><a href="#配置-launch-json" class="headerlink" title="配置 launch.json"></a>配置 launch.json</h4><p>&emsp;&emsp;进入左侧的调试页面，点击<strong>创建launch.json文件</strong>，就会自动在你的工作目录下新建一个.vscode文件来存放你的调试配置。这里我们选择C/C++: (lldb) Launch。</p>
<center>
    <img style="border-radius: 0.3125em; margin-top: 10px; width: 400px; height: 200px; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src="https://blog-1253514421.cos.ap-shanghai.myqcloud.com/image-5.png">
    <br>
</center>

<p>&emsp;&emsp;<strong>launch.json</strong>这个文件中的配置，<a href="https://go.microsoft.com/fwlink/?linkid=830387" target="_blank" rel="noopener">官方的文档</a>里有详细的说明。下面的配置，是我通过不断尝试所最终决定下来的。其中唯一特别的是这块：<code>&quot;program&quot;: &quot;${workspaceFolder}/tmp/${fileBasenameNoExtension}.out&quot;</code> 它会在当前目录下新建一个tmp的文件夹来存放编译后的文件，这样的好处是，有一个专门存放编译文件的地方，让程序所在的目录看起来清爽点。如果对以下配置有不接的地方，只要将<strong>鼠标长放在对应参数上</strong>就行了，它会显示出对应配置的说明。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;version&quot;: &quot;0.2.0&quot;,</span><br><span class="line">    &quot;configurations&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;preLaunchTask&quot;: &quot;c++&quot;,</span><br><span class="line">            &quot;name&quot;: &quot;(lldb) Launch&quot;,</span><br><span class="line">            &quot;type&quot;: &quot;lldb&quot;,</span><br><span class="line">            &quot;request&quot;: &quot;launch&quot;,</span><br><span class="line">            &quot;program&quot;: &quot;$&#123;workspaceFolder&#125;&#x2F;tmp&#x2F;$&#123;fileBasenameNoExtension&#125;.out&quot;,</span><br><span class="line">            &quot;args&quot;: [],</span><br><span class="line">            &quot;stopAtEntry&quot;: false,</span><br><span class="line">            &quot;cwd&quot;: &quot;$&#123;workspaceFolder&#125;&quot;,</span><br><span class="line">            &quot;environment&quot;: [],</span><br><span class="line">            &quot;externalConsole&quot;: true,</span><br><span class="line">            &quot;MIMode&quot;: &quot;lldb&quot;,</span><br><span class="line">            &quot;logging&quot;: &#123;</span><br><span class="line">                &quot;trace&quot;: true,</span><br><span class="line">                &quot;traceResponse&quot;: true,</span><br><span class="line">                &quot;engineLogging&quot;: true,</span><br><span class="line">                &quot;programOutput&quot;: true,</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="配置-task-json"><a href="#配置-task-json" class="headerlink" title="配置 task.json"></a>配置 task.json</h4><p>&emsp;&emsp;这里我们直接使用快捷键<strong>command + P</strong>，然后在弹出的搜索框中输入 <strong>&gt;task</strong> 来新建一个生成任务即可。</p>
<center>
    <img style="border-radius: 0.3125em; margin-top: 10px; width: 400px; height: 120px; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src="https://blog-1253514421.cos.ap-shanghai.myqcloud.com/1581579434251.jpg">
    <br>
</center>

<p>&emsp;&emsp;打开<strong>task.json</strong>这个文件，对其进行以下配置。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;version&quot;: &quot;2.0.0&quot;,</span><br><span class="line">    &quot;tasks&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;label&quot;: &quot;c++&quot;,</span><br><span class="line">            &quot;type&quot;: &quot;shell&quot;,</span><br><span class="line">            &quot;command&quot;: &quot;g++&quot;,</span><br><span class="line">            &quot;args&quot;: [</span><br><span class="line">                &quot;$&#123;file&#125;&quot;,</span><br><span class="line">                &quot;-std&#x3D;c++17&quot;,</span><br><span class="line">                &quot;-o&quot;,</span><br><span class="line">                &quot;$&#123;workspaceFolder&#125;&#x2F;tmp&#x2F;$&#123;fileBasenameNoExtension&#125;.out&quot;,</span><br><span class="line">                &quot;-g&quot;</span><br><span class="line">            ],</span><br><span class="line">            &quot;group&quot;: &quot;build&quot;,</span><br><span class="line">            &quot;presentation&quot;: &#123;</span><br><span class="line">                &quot;echo&quot;: true,</span><br><span class="line">                &quot;focus&quot;: false,</span><br><span class="line">                &quot;panel&quot;: &quot;shared&quot;,</span><br><span class="line">                &quot;showReuseMessage&quot;: true,</span><br><span class="line">                &quot;clear&quot;: true,</span><br><span class="line">                &quot;reveal&quot;: &quot;silent&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="测试配置"><a href="#测试配置" class="headerlink" title="测试配置"></a>测试配置</h3><p>&emsp;&emsp;上述步骤都正确完成后，那么就新建一个c++程序来测试下环境是否配置成功吧。</p>
<h4 id="编写一个简单的demo"><a href="#编写一个简单的demo" class="headerlink" title="编写一个简单的demo"></a>编写一个简单的demo</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int a &#x3D; 1;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="设置断点，并编译代码"><a href="#设置断点，并编译代码" class="headerlink" title="设置断点，并编译代码"></a>设置断点，并编译代码</h4><p>&emsp;&emsp;vscode设置断点的方式和其他IDE一样，如果是在不清楚的话，建议搜一下。然后你可以选择在调试界面中，单击<strong>运行和调试旁的三角形</strong>，也可以直接使用快捷键<strong>FN + F5</strong>来进行调试。程序编译运行后，可以在<strong>vscode左边</strong>看见对应调试信息，然后可以在<strong>vscode上边</strong>看见控制工具栏。如果这些都能看见，并且弹出对应的控制台，那么环境就配置成功了。</p>
<center>
    <img style="border-radius: 0.3125em; margin-top: 10px; width: 600px; height: 200px; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src="https://blog-1253514421.cos.ap-shanghai.myqcloud.com/1581580268989.jpg">
    <br>
</center>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>&emsp;&emsp;以上就是在Mac OS上使用vscode配置C++/C语言的开发环境。后期可以根据自己的需求，去修改配置文件对应的选项，并对vscode进行一些个性化修改就是了。经过一段时间使用，vscode在日常使用来讲，给我的感觉远比使用IDE来的舒适，因此希望你也会喜欢。</p>
]]></content>
      <categories>
        <category>日常折腾</category>
        <category>C++</category>
      </categories>
      <tags>
        <tag>vscode</tag>
        <tag>macOS</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Hexo与GitHub Pages来搭建个人博客</title>
    <url>/2020/02/06/zioang-blog/</url>
    <content><![CDATA[<h2 id="缘由"><a href="#缘由" class="headerlink" title="缘由"></a>缘由</h2><p>&emsp;&emsp;这段时间因为疫情而一直呆在家里快无聊疯了，寻思着找点事干。刚好现在准备学点东西，然后想做做笔记什么的，于是就有了这个博客的诞生。</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&emsp;&emsp;博客是由<a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">Hexo</a>与<a href="https://pages.github.com/" target="_blank" rel="noopener">GitHub Pages</a>结合搭建的一个静态网站，由于之前完全没接触过<a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">Hexo</a>这个框架，于是乎就打算以此作为博客的第一篇文章，边学习边记录，并来记录下她诞生的过程。</p>
<a id="more"></a>
<h2 id="搭建需求"><a href="#搭建需求" class="headerlink" title="搭建需求"></a>搭建需求</h2><ul>
<li>首先得有个<a href="https://github.com/" target="_blank" rel="noopener">GitHub</a>账号，登录后点击<strong>New repository</strong>来创建一个新仓库，仓库名必须为：用户名.github.io（<strong>这个用户名是你GitHub的账号名称</strong>）。下面这张图片，就是我创建的对应仓库。</li>
</ul>
<center>
    <img style="border-radius: 0.3125em; margin-top: 10px; width: 400px; height: 250px; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src="https://blog-1253514421.cos.ap-shanghai.myqcloud.com/7F609234-C606-4B5B-B2FA-FA1890A0EA0A.png">
    <br>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">仓库名</div>
</center>

<ul>
<li>安装<a href="https://git-scm.com/download/win" target="_blank" rel="noopener">Git</a>，这里对于Git的安装和配置不多介绍，善用下搜索引擎。</li>
<li>安装<a href="https://nodejs.org/en/download/" target="_blank" rel="noopener">Node.js</a>，因为我用的是MacOS系统，所以介绍下如何在Mac上安装Node.js。<ul>
<li>确保自己的电脑上有<a href="https://brew.sh/" target="_blank" rel="noopener">HomeBrew</a>，没有的话直接去打开终端然后运行这段命令：  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;usr&#x2F;bin&#x2F;ruby -e &quot;$(curl -fsSL https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;Homebrew&#x2F;install&#x2F;master&#x2F;install)&quot;</span><br></pre></td></tr></table></figure></li>
<li>接下来事情就简单了，直接在终端中有<strong>HomeBrew</strong>安装Node.js即可，输入以下命令:  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew install node</span><br></pre></td></tr></table></figure>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew install npm</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>安装<a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">Hexo</a>，因为第二步的时候已经安装好了npm，所以现在我们可以直接通过npm来安装<strong>Hexo</strong>了，在终端中输入以下命令：  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo npm install -g hexo-cli</span><br></pre></td></tr></table></figure>
<ul>
<li>这里注意下，安装过程中可能会报以下错误  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">┌───────────────────────────────────────────────────────────────────┐</span><br><span class="line">│                      npm update check failed                      │</span><br><span class="line">│                Try running with sudo or get access                │</span><br><span class="line">│               to the local update config store via                │</span><br><span class="line">│ sudo chown -R $USER:$(id -gn $USER) &#x2F;Users&#x2F;veritystothard&#x2F;.config │</span><br><span class="line">└───────────────────────────────────────────────────────────────────┘</span><br><span class="line">module.js:491</span><br><span class="line">    throw err;</span><br><span class="line">    ^</span><br><span class="line"></span><br><span class="line">Error: Cannot find module &#39;proto-list&#39;</span><br><span class="line">    at Function.Module._resolveFilename (module.js:489:15)</span><br><span class="line">    at Function.Module._load (module.js:439:25)</span><br><span class="line">    at Module.require (module.js:517:17)</span><br><span class="line">    at require (internal&#x2F;module.js:11:18)</span><br><span class="line">    at Object.&lt;anonymous&gt; (&#x2F;usr&#x2F;local&#x2F;lib&#x2F;node_modules&#x2F;npm&#x2F;node_modules&#x2F;config-chain&#x2F;index.js:1:79)</span><br><span class="line">    at Module._compile (module.js:573:30)</span><br><span class="line">    at Object.Module._extensions..js (module.js:584:10)</span><br><span class="line">    at Module.load (module.js:507:32)</span><br><span class="line">    at tryModuleLoad (module.js:470:12)</span><br><span class="line">    at Function.Module._load (module.js:462:3)</span><br><span class="line"></span><br><span class="line">其解决方法就是更改下配置权限: sudo chown -R $USER:$(id -gn $USER) ~&#x2F;.config</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h2 id="初始化博客项目"><a href="#初始化博客项目" class="headerlink" title="初始化博客项目"></a>初始化博客项目</h2><p>&emsp;&emsp;在终端中进入项目想要创建的路径，然后输入：<code>hexo init blog(这里的blog可以更改为你想要的项目名)</code> 这里有一点需要注意下的是，安装过程中可能会因<strong>xcode-select</strong>的版本而报错，因此更新下版本就好了，在终端中依次输入以下命令即可：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo rm -rf &#x2F;Library&#x2F;Developer&#x2F;CommandLineTools</span><br><span class="line">xcode-select --install</span><br></pre></td></tr></table></figure><br>&emsp;&emsp;项目安装结束后，我们来写第一篇文章来测试下效果吧。为了检测我们的网站雏形，分别按顺序输入以下三条命令（<strong>注意，所有的Hexo命令都要在对应blog的根目录出运行</strong>）：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo n first</span><br><span class="line"></span><br><span class="line">hexo g</span><br><span class="line"></span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure><br>命令运行完成后，打开浏览器输入<a href="http://127.0.0.1:4000/" target="_blank" rel="noopener">127.0.0.1:4000</a>，即可了解网站的详细内容。</p>
<center>
    <img style="border-radius: 0.3125em; margin-top: 10px; width: 600px; height: 400px; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src="https://blog-1253514421.cos.ap-shanghai.myqcloud.com/B9B73842-F4E2-449D-966B-06D7D5DAA9F6.png">
    <br>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">博客主页</div>
</center>

<p>这里的first就是我们刚刚新建的文章。</p>
<p>&emsp;&emsp;下面介绍下<strong>Hexo</strong>的常用命令：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo -g # 安装Hexo</span><br><span class="line">npm update hexo -g # 升级</span><br><span class="line">hexo init xxx # 初始化博客</span><br><span class="line"></span><br><span class="line">hexo n &quot;blog name&quot; # 新建文章，会在&#x2F;source&#x2F;_posts&#x2F;这个路径下生成一个新的md，因此文章内容按照Markdwon格式来写就行了</span><br><span class="line">hexo g &#x3D;&#x3D; hexo generate # 生成</span><br><span class="line">hexo s &#x3D;&#x3D; hexo server # 启动服务预览</span><br><span class="line">hexo d &#x3D;&#x3D; hexo deploy # 部署</span><br><span class="line"></span><br><span class="line">hexo server # Hexo会监视文件变动并自动更新，无须重启服务器</span><br><span class="line">hexo server -s # 静态模式</span><br><span class="line">hexo server -p 5000 # 更改端口</span><br><span class="line">hexo server -i 192.168.1.1 # 自定义 IP</span><br><span class="line">hexo clean # 清除缓存，若是网页正常情况下可以忽略这条命令</span><br></pre></td></tr></table></figure></p>
<h2 id="更改网站的主题"><a href="#更改网站的主题" class="headerlink" title="更改网站的主题"></a>更改网站的主题</h2><p>&emsp;&emsp;我用的是<a href="https://github.com/Shen-Yu/hexo-theme-ayer" target="_blank" rel="noopener">Ayer</a>主题，如果想要试试其他主题的话，可以到Hexo官网的<a href="https://hexo.io/themes/" target="_blank" rel="noopener">主题专栏</a>中找找有没有喜欢的。找到自己新颖的主题后，在终端用<strong>Git</strong>克隆对应主题到blog目录下即可，这里以Ayer主题为例，在终端输入：<code>git clone https://github.com/Shen-Yu/hexo-theme-ayer.git themes/ayer</code>。<br>&emsp;&emsp;耐心等待主题安装完成后，在终端中输入(路径为blog根目录)：<code>vi _config.yml</code>。在该配置文件中找到<strong>theme</strong>这个配置项，将其更改为<code>theme: ayer</code>就行了。</p>
<center>
    <img style="border-radius: 0.3125em; margin-top: 10px; width: 600px; height: 400px; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src="https://blog-1253514421.cos.ap-shanghai.myqcloud.com/4A0F3F66-62FA-4A8D-8714-7D0E86390D29.png">
    <br>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">新更换的主题</div>
</center>

<p>&emsp;&emsp;这里对于主题的配置不多介绍，每个主题都有对应的文档可以查看，而且挺多都是有中文文档的，因此绝对比我讲的更加清晰。</p>
<h2 id="推送网站"><a href="#推送网站" class="headerlink" title="推送网站"></a>推送网站</h2><p>&emsp;&emsp;<a href="https://hexo.io/zh-cn/docs/one-command-deployment" target="_blank" rel="noopener">Hexo官方</a>给出了多种推送方式，这里我们用<strong>Git</strong>来推送网站。首先，我们安装下<strong>Git</strong>的部署插件，在终端中输入命令(<strong>blog根目录下</strong>)：<code>npm install hexo-deployer-git --save</code> 然后，我们在终端中输入：<code>vi _config.yml</code>，在该文件中找到<strong>deploy</strong>这一项，完成以下配置：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">    type: git</span><br><span class="line">    repo: 仓库的完整路径</span><br><span class="line">    branch: master</span><br></pre></td></tr></table></figure></p>
<center>
    <img style="border-radius: 0.3125em; margin-top: 10px; width: 600px; height: 200px; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src="https://blog-1253514421.cos.ap-shanghai.myqcloud.com/8EBEB1C6-61E5-4B7B-9CB9-9F55EA364450.png">
    <br>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">需修改的配置</div>
</center>

<p>&emsp;&emsp;完成以上配置后，保存退出配置文档，在终端依次输入下面这三条命令后，等待命令运行结束，并观察终端是否显示上传成功的信息。如上传成功后，打开浏览器，在地址栏输入你的放置个人网站的仓库路径，即<a href="http://xxx.github.io" target="_blank" rel="noopener">xxx.github.io</a> （这里的xxx是你的仓库名）。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo clean </span><br><span class="line">hexo g </span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure></p>
<center>
    <img style="border-radius: 0.3125em; margin-top: 10px; width: 700px; height: 400px; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src="https://blog-1253514421.cos.ap-shanghai.myqcloud.com/D17E2895-E74B-4BF7-9A8F-0AE4EF3C991D.png ">
    <br>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">访问博客主页</div>
</center>

<p>&emsp;&emsp;至此，我们的博客算是正式创建好了，之后就可以根据自己的需求进行个性化更改了。</p>
<h2 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h2><p>&emsp;&emsp;博客的域名是可以自定义的，只要你有一个属于自己的域名，那么你就可以将GitHub提供的这个链接替换成自己的专属域名。如果需要的话，可以利用搜索引擎查找下，这类资料网上还是挺多的。</p>
<p><a href= "https://github.com/zioang/zioang.github.io" target="_blank" style="margin-top: 20px; text-decoration: none;"><br>    <img src="https://blog-1253514421.cos.ap-shanghai.myqcloud.com/github.png" style="width: 20px; height: 20px; margin-right: 6px; float: left"><br>    <p style=" line-height: 20px; font-size: 16px; color: black; font-family: Hiragino Sans GB, WenQuanYi Micro Hei;">项目地址</p>
</a></p>
]]></content>
      <categories>
        <category>日常折腾</category>
      </categories>
      <tags>
        <tag>macOS</tag>
        <tag>博客相关</tag>
      </tags>
  </entry>
</search>
